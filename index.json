[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/contracts/AbstractContract.js",
    "content": "import _ from 'lodash'\n\nimport isRequired from '../utils/isRequired'\nimport delegateCalls from '../utils/delegateCalls'\n\n/**\n * Abstract Contract holds a contract implementation to make calls to the blockchain but\n * also includes methods that interact with the off chain store. NOTE all methods that\n * the underlying contract implementation expose can be called directly from an Abstract contract.\n */\nclass AbstractContract {\n  /**\n   * AbstractContract wraps an implementation instance to provide access to higher level\n   * services such as an off chain store, as well as the functionality of the underlying\n   * implementation.\n   * @param {object} implementationInstance - Contract Implementation object to extend\n   * @param {object} storeProviderInstance - StoreProvider wrapper object.\n   */\n  constructor(\n    implementationInstance = isRequired('implementationInstance'),\n    storeProviderInstance = isRequired('storeProviderInstance')\n  ) {\n    this._StoreProvider = storeProviderInstance\n    this._contractImplementation = implementationInstance\n    delegateCalls(this, implementationInstance)\n  }\n\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProvider = storeProviderInstance\n  }\n}\n\nexport default AbstractContract\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/AbstractContract.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "AbstractContract",
    "memberof": "src/contracts/AbstractContract.js",
    "static": true,
    "longname": "src/contracts/AbstractContract.js~AbstractContract",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/AbstractContract.js",
    "importStyle": "AbstractContract",
    "description": "Abstract Contract holds a contract implementation to make calls to the blockchain but\nalso includes methods that interact with the off chain store. NOTE all methods that\nthe underlying contract implementation expose can be called directly from an Abstract contract.",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#constructor",
    "access": "public",
    "description": "AbstractContract wraps an implementation instance to provide access to higher level\nservices such as an off chain store, as well as the functionality of the underlying\nimplementation.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "implementationInstance",
        "description": "Contract Implementation object to extend"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "StoreProvider wrapper object."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "_StoreProvider",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#_StoreProvider",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "_contractImplementation",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#_contractImplementation",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/contracts/ContractImplementation.js",
    "content": "import contract from 'truffle-contract'\nimport _ from 'lodash'\n\nimport isRequired from '../utils/isRequired'\nimport * as errorConstants from '../constants/error'\nimport Web3Wrapper from '../utils/Web3Wrapper'\n\n/**\n * ContractImplementation is a parent class for on chain contracts. It loads the contract from the\n * blockchain and exposes the contract instance for use by the child.\n */\nclass ContractImplementation {\n  constructor(\n    web3Provider = isRequired('web3Provider'),\n    artifact = isRequired('artifact'),\n    contractAddress\n  ) {\n    this.contractAddress = contractAddress\n    this.artifact = artifact\n    this.contractInstance = null\n    this._Web3Wrapper = new Web3Wrapper(web3Provider)\n    // loading params\n    this._contractLoadedResolver = null\n    this._contractLoadedRejecter = null\n    this._loadingContractInstance = null\n    this.isLoading = false\n  }\n\n  /**\n   * Load contract instance if not yet initialized. Returns loading promise\n   * @returns {Promise} resolves to contractInstance\n   */\n  loadContract = async () => {\n    if (this.isLoading) return this._loadingContractInstance\n    if (this.contractInstance) return this.contractInstance\n\n    if (!this.contractAddress || !this.artifact)\n      throw new Error(errorConstants.CONTRACT_INSTANCE_NOT_SET)\n\n    const newLoadingPromise = this._newLoadingPromise()\n    this._loadingContractInstance = newLoadingPromise\n    this._load()\n    return newLoadingPromise\n  }\n\n  /**\n   * Get the web3 provider object from the initialized web3 instance\n   * @returns {object} web3 provider object\n   */\n  getWeb3Provider = () => this._Web3Wrapper.getProvider()\n\n  /**\n   * MetaMask safe get block data by blockNumber\n   * @param {Int} blockNumber - Block number\n   * @returns {Promise} block object\n   */\n  getBlock = async blockNumber => this._Web3Wrapper.getBlock(blockNumber)\n\n  /**\n   * Set a new contract instance\n   * @param {string} contractAddress - The address of the contract\n   * @param {object} artifact - Contract artifact to use to load contract\n   * @returns {object} contractInstance object\n   */\n  setContractInstance = async (\n    contractAddress = this.contractAddress,\n    artifact = this.artifact\n  ) => {\n    this.contractAddress = contractAddress\n    this.artifact = artifact\n    this.contractInstance = null\n    return this.loadContract()\n  }\n\n  /**\n   * Load an existing contract from the current artifact and address\n   */\n  _load = async () => {\n    this.isLoading = true\n    try {\n      this.contractInstance = await this._instantiateContractIfExistsAsync(\n        this.artifact,\n        this.contractAddress\n      )\n\n      this.isLoading = false\n      this._contractLoadedResolver(this.contractInstance)\n    } catch (err) {\n      this.isLoading = false\n      this._contractLoadedRejecter(err)\n    }\n  }\n\n  /**\n   * Instantiate contract.\n   * @private\n   * @param {object} artifact - The contract artifact.\n   * @param {string} address - The hex encoded contract Ethereum address\n   * @returns {object} - The contract instance.\n   */\n  _instantiateContractIfExistsAsync = async (artifact, address) => {\n    try {\n      const c = await contract(artifact)\n      await c.setProvider(await this._Web3Wrapper.getProvider())\n      const contractInstance = _.isUndefined(address)\n        ? await c.deployed()\n        : await c.at(address)\n\n      // Estimate gas before sending transactions\n      for (const funcABI of contractInstance.abi) {\n        // Check for non-constant functions\n        if (funcABI.type === 'function' && funcABI.constant === false) {\n          const func = contractInstance[funcABI.name]\n\n          // eslint-disable-next-line no-loop-func\n          contractInstance[funcABI.name] = async (...args) => {\n            await func.estimateGas(...args) // Estimate gas (also checks for possible failures)\n            return func(...args) // Call original function\n          }\n\n          // Keep reference to the original function for special cases\n          contractInstance[funcABI.name].original = func\n\n          // Forward other accessors to the original function\n          Object.setPrototypeOf(contractInstance[funcABI.name], func)\n        }\n      }\n\n      return contractInstance\n    } catch (err) {\n      console.error(err)\n\n      if (_.includes(err.message, 'not been deployed to detected network'))\n        throw new Error(errorConstants.CONTRACT_NOT_DEPLOYED)\n\n      throw new Error(errorConstants.UNABLE_TO_LOAD_CONTRACT)\n    }\n  }\n\n  /**\n   * Create a new Promise to be used in loading the contract.\n   * @returns {Promise} - Resolves to contract instance.\n   */\n  _newLoadingPromise = () =>\n    new Promise((resolve, reject) => {\n      this._contractLoadedResolver = resolve\n      this._contractLoadedRejecter = reject\n    })\n\n  /**\n   * Get the contract address for the currently instantiated contract.\n   * @returns {string} - The address of the contract.\n   */\n  getContractAddress = () => this.contractAddress\n}\n\nexport default ContractImplementation\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/ContractImplementation.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "class",
    "name": "ContractImplementation",
    "memberof": "src/contracts/ContractImplementation.js",
    "static": true,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/ContractImplementation.js",
    "importStyle": "ContractImplementation",
    "description": "ContractImplementation is a parent class for on chain contracts. It loads the contract from the\nblockchain and exposes the contract instance for use by the child.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 57,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "contractAddress",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#contractAddress",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "artifact",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#artifact",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "contractInstance",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#contractInstance",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "_Web3Wrapper",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_Web3Wrapper",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_contractLoadedResolver",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_contractLoadedResolver",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_contractLoadedRejecter",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_contractLoadedRejecter",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "_loadingContractInstance",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_loadingContractInstance",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "isLoading",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#isLoading",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "loadContract",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#loadContract",
    "access": "public",
    "description": "Load contract instance if not yet initialized. Returns loading promise",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} resolves to contractInstance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "resolves to contractInstance"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "getWeb3Provider",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#getWeb3Provider",
    "access": "public",
    "description": "Get the web3 provider object from the initialized web3 instance",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "web3 provider object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "member",
    "name": "getBlock",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#getBlock",
    "access": "public",
    "description": "MetaMask safe get block data by blockNumber",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} block object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Int"
        ],
        "spread": false,
        "optional": false,
        "name": "blockNumber",
        "description": "Block number"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "block object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "setContractInstance",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#setContractInstance",
    "access": "public",
    "description": "Set a new contract instance",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} contractInstance object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "The address of the contract"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "artifact",
        "description": "Contract artifact to use to load contract"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "contractInstance object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "_load",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_load",
    "access": "private",
    "description": "Load an existing contract from the current artifact and address",
    "lineNumber": 78,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "_instantiateContractIfExistsAsync",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_instantiateContractIfExistsAsync",
    "access": "private",
    "description": "Instantiate contract.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The contract instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "artifact",
        "description": "The contract artifact."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "address",
        "description": "The hex encoded contract Ethereum address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The contract instance."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "_newLoadingPromise",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_newLoadingPromise",
    "access": "private",
    "description": "Create a new Promise to be used in loading the contract.",
    "lineNumber": 144,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Resolves to contract instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves to contract instance."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "getContractAddress",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#getContractAddress",
    "access": "public",
    "description": "Get the contract address for the currently instantiated contract.",
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The address of the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The address of the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "file",
    "name": "src/contracts/abstractions/Arbitrable.js",
    "content": "import AbstractContract from '../AbstractContract'\n\n/**\n * Arbitrable Abstract Contarct API. This wraps an arbitrable contract. It provides\n * interaction with both the off chain store as well as the arbitrable instance. All\n * arbitrable methods from the supplied contract implementation can be called from this\n * object.\n */\nclass ArbitrableContract extends AbstractContract {\n  /**\n   * Deploy a contract and add to the Store.\n   * @param {string} account - Ethereum address.\n   * @param {int} value - funds to be placed in contract.\n   * @param {string} hashContract - Keccak hash of the plain English contract.\n   * @param {string} arbitratorAddress - The address of the arbitrator contract.\n   * @param {int} timeout - Time after which a party automatically loose a dispute.\n   * @param {string} partyB - Ethereum address of the other party in the contract.\n   * @param {bytes} arbitratorExtraData - Extra data for the arbitrator.\n   * @param {string} email - Email address of the contract creator (default empty string).\n   * @param {string} title - Title of the contract (default empty string).\n   * @param {string} description - Description of what the contract is about (default empty string).\n   * @param {...any} args - Extra arguments for the contract.\n   * @returns {object | Error} - The contract object or an error.\n   */\n  deploy = async (\n    account,\n    value,\n    hashContract,\n    arbitratorAddress,\n    timeout,\n    partyB,\n    arbitratorExtraData = '',\n    email = '',\n    title = '',\n    description = '',\n    ...args\n  ) => {\n    const contractInstance = await this._contractImplementation.constructor.deploy(\n      account,\n      value,\n      hashContract,\n      arbitratorAddress,\n      timeout,\n      partyB,\n      arbitratorExtraData,\n      this._contractImplementation.getWeb3Provider(),\n      ...args\n    )\n\n    const newContract = await this._StoreProvider.updateContract(\n      account,\n      contractInstance.address,\n      {\n        hashContract,\n        partyA: account,\n        partyB,\n        arbitrator: arbitratorAddress,\n        timeout,\n        email,\n        title,\n        description\n      }\n    )\n\n    return newContract\n  }\n\n  /**\n   * Submit evidence.\n   * @param {string} account - ETH address of user.\n   * @param {string} name - Name of evidence.\n   * @param {string} description - Description of evidence.\n   * @param {string} url - A link to an evidence using its URI.\n   * @returns {string} - txHash Hash transaction.\n   */\n  submitEvidence = async (account, name, description = '', url) => {\n    const txHash = await this._contractImplementation.submitEvidence(\n      account,\n      name,\n      description,\n      url\n    )\n\n    await this._StoreProvider.addEvidenceContract(\n      this._contractImplementation.contractAddress,\n      account,\n      name,\n      description,\n      url\n    )\n\n    return txHash\n  }\n\n  /**\n   * Get all contracts TODO do we need to get contract data from blockchain?\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Contract data from store.\n   */\n  getContractsForUser = async account => {\n    // fetch user profile\n    const userProfile = await this._StoreProvider.setUpUserProfile(account)\n\n    return userProfile.contracts\n  }\n\n  /**\n   * Get evidence for contract.\n   * @param {string} contractAddress - Address of arbitrable contract.\n   * @returns {object[]} - Array of evidence objects.\n   */\n  getEvidenceForArbitrableContract = async () => {\n    const arbitrableContractData = await this._contractImplementation.getData()\n    const partyAContractData = await this._StoreProvider.getContractByAddress(\n      arbitrableContractData.partyA,\n      this._contractImplementation.contractAddress\n    )\n    const partyBContractData = await this._StoreProvider.getContractByAddress(\n      arbitrableContractData.partyB,\n      this._contractImplementation.contractAddress\n    )\n\n    const partyAEvidence = (partyAContractData\n      ? partyAContractData.evidences\n      : []\n    ).map(evidence => {\n      evidence.submitter = arbitrableContractData.partyA\n      return evidence\n    })\n    const partyBEvidence = (partyBContractData\n      ? partyBContractData.evidences\n      : []\n    ).map(evidence => {\n      evidence.submitter = arbitrableContractData.partyB\n      return evidence\n    })\n\n    return partyAEvidence.concat(partyBEvidence)\n  }\n\n  /**\n   * Fetch all data from the store on the current contract.\n   * @returns {object} - Store data for contract.\n   */\n  getDataFromStore = async () => {\n    const contractInstance = await this._contractImplementation.loadContract()\n    const partyA = await contractInstance.partyA()\n\n    return this._StoreProvider.getContractByAddress(\n      partyA,\n      this._contractImplementation.contractAddress\n    )\n  }\n\n  /**\n   * Get data from the store and contract for Arbitrable Contract.\n   * @param {string} account - ETH address of user.\n   * @returns {object} - Contract data.\n   */\n  getData = async account => {\n    const contractData = await this._contractImplementation.getData()\n\n    let storeData = {}\n    if (account)\n      storeData = await this._StoreProvider.getContractByAddress(\n        account,\n        this._contractImplementation.contractAddress\n      )\n\n    return Object.assign({}, storeData, contractData)\n  }\n}\n\nexport default ArbitrableContract\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/abstractions/Arbitrable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 85,
    "kind": "class",
    "name": "ArbitrableContract",
    "memberof": "src/contracts/abstractions/Arbitrable.js",
    "static": true,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/abstractions/Arbitrable.js",
    "importStyle": "ArbitrableContract",
    "description": "Arbitrable Abstract Contarct API. This wraps an arbitrable contract. It provides\ninteraction with both the off chain store as well as the arbitrable instance. All\narbitrable methods from the supplied contract implementation can be called from this\nobject.",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "src/contracts/AbstractContract.js~AbstractContract"
    ]
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#deploy",
    "access": "public",
    "description": "Deploy a contract and add to the Store.",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object | Error} - The contract object or an error."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum address."
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "funds to be placed in contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hashContract",
        "description": "Keccak hash of the plain English contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Time after which a party automatically loose a dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "partyB",
        "description": "Ethereum address of the other party in the contract."
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorExtraData",
        "description": "Extra data for the arbitrator."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": "Email address of the contract creator (default empty string)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "title",
        "description": "Title of the contract (default empty string)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "Description of what the contract is about (default empty string)."
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Extra arguments for the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object ",
        " Error"
      ],
      "spread": false,
      "description": "The contract object or an error."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "submitEvidence",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#submitEvidence",
    "access": "public",
    "description": "Submit evidence.",
    "lineNumber": 76,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - txHash Hash transaction."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "Description of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to an evidence using its URI."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "txHash Hash transaction."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "getContractsForUser",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#getContractsForUser",
    "access": "public",
    "description": "Get all contracts TODO do we need to get contract data from blockchain?",
    "lineNumber": 100,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Contract data from store."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Contract data from store."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "getEvidenceForArbitrableContract",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#getEvidenceForArbitrableContract",
    "access": "public",
    "description": "Get evidence for contract.",
    "lineNumber": 112,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of evidence objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of arbitrable contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of evidence objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "getDataFromStore",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#getDataFromStore",
    "access": "public",
    "description": "Fetch all data from the store on the current contract.",
    "lineNumber": 145,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Store data for contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Store data for contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#getData",
    "access": "public",
    "description": "Get data from the store and contract for Arbitrable Contract.",
    "lineNumber": 160,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Contract data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Contract data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "file",
    "name": "src/contracts/abstractions/Arbitrator.js",
    "content": "import _ from 'lodash'\n\nimport * as arbitratorConstants from '../../constants/arbitrator'\nimport AbstractContract from '../AbstractContract'\n\n/**\n * Arbitrator Abstract Contarct API. This wraps an arbitrator contract. It provides\n * interaction with both the off chain store as well as the arbitrator instance. All\n * arbitrator methods from the supplied contract implementation can be called from this\n * object.\n */\nclass Arbitrator extends AbstractContract {\n  /**\n   * Get disputes for user with extra data from arbitrated transaction and store\n   * @param {string} account address of user\n   * @returns {object[]} dispute data objects for user\n   */\n  getDisputesForUser = async account => {\n    // contract data\n    const [period, currentSession] = await Promise.all([\n      this._contractImplementation.getPeriod(),\n      this._contractImplementation.getSession()\n    ])\n\n    const _getDisputesForUserFromStore = async account =>\n      Promise.all(\n        (await this._StoreProvider.getDisputes(account)).map(dispute =>\n          this._contractImplementation.getDispute(dispute.disputeId)\n        )\n      )\n\n    // new jurors have not been chosen yet. don't update\n    if (period !== arbitratorConstants.PERIOD.VOTE) {\n      return _getDisputesForUserFromStore(account)\n    }\n\n    let profile = await this._StoreProvider.setUpUserProfile(account)\n    if (currentSession !== profile.session) {\n      // get disputes for juror\n      const myDisputes = await this._contractImplementation.getDisputesForJuror(\n        account\n      )\n\n      // update user profile for each dispute\n      await Promise.all(\n        myDisputes.map(async dispute => {\n          // update profile for account\n          await this._StoreProvider.updateDisputeProfile(\n            account,\n            dispute.arbitratorAddress,\n            dispute.disputeId,\n            {\n              appealDraws: dispute.appealDraws\n            }\n          )\n        })\n      )\n\n      this._StoreProvider.updateUserProfile(account, {\n        session: currentSession\n      })\n    }\n\n    return _getDisputesForUserFromStore(account)\n  }\n\n  /**\n   * Buy PNK.\n   * @param {number} amount - Number of pinakion to buy.\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Balance of user.\n   */\n  buyPNK = async (amount, account) => {\n    await this._contractImplementation.buyPNK(amount, account)\n    return this._contractImplementation.getPNKBalance(account)\n  }\n}\n\nexport default Arbitrator\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/abstractions/Arbitrator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "class",
    "name": "Arbitrator",
    "memberof": "src/contracts/abstractions/Arbitrator.js",
    "static": true,
    "longname": "src/contracts/abstractions/Arbitrator.js~Arbitrator",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/abstractions/Arbitrator.js",
    "importStyle": "Arbitrator",
    "description": "Arbitrator Abstract Contarct API. This wraps an arbitrator contract. It provides\ninteraction with both the off chain store as well as the arbitrator instance. All\narbitrator methods from the supplied contract implementation can be called from this\nobject.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "src/contracts/AbstractContract.js~AbstractContract"
    ]
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "getDisputesForUser",
    "memberof": "src/contracts/abstractions/Arbitrator.js~Arbitrator",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrator.js~Arbitrator#getDisputesForUser",
    "access": "public",
    "description": "Get disputes for user with extra data from arbitrated transaction and store",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} dispute data objects for user"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "dispute data objects for user"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "buyPNK",
    "memberof": "src/contracts/abstractions/Arbitrator.js~Arbitrator",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrator.js~Arbitrator#buyPNK",
    "access": "public",
    "description": "Buy PNK.",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Balance of user."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "Number of pinakion to buy."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Balance of user."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "src/contracts/abstractions/index.js",
    "content": "import Arbitrator from './Arbitrator'\nimport Arbitrable from './Arbitrable'\n\nexport { Arbitrator, Arbitrable }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/abstractions/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "file",
    "name": "src/contracts/implementations/PNK/PinakionPOC.js",
    "content": "import PinakionPOCArtifact from 'kleros/build/contracts/PinakionPOC' // FIXME: mock\nimport _ from 'lodash'\n\nimport * as ethConstants from '../../../constants/eth'\nimport * as errorConstants from '../../../constants/error'\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\n/**\n * Provides interaction with a PinakionPOC contract deployed on the blockchain.\n */\nclass PinakionPOC extends ContractImplementation {\n  /**\n   * Constructor PinakionPOC.\n   * @param {object} web3Provider - web3 instance.\n   * @param {string} contractAddress - of the contract (optionnal).\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, PinakionPOCArtifact, contractAddress)\n  }\n\n  /**\n   * Deploy a new instance of PinakionPOC.\n   * @param {string} account - account of user\n   * @param {object} web3Provider - web3 provider object\n   * @returns {object} - 'truffle-contract' Object | err The contract object or error deploy.\n   */\n  static deploy = async (account, web3Provider) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      ethConstants.TRANSACTION.VALUE,\n      PinakionPOCArtifact,\n      web3Provider\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Change the kleros contract variable in instance of PinakionPOC.\n   * @param {string} klerosAddress - Address of Kleros POC contract.\n   * @param {string} account - Address of user.\n   * @returns {object} - The result transaction object.\n   */\n  setKleros = async (\n    klerosAddress,\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.setKleros(klerosAddress, {\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_SET_KLEROS)\n    }\n  }\n\n  /**\n   * Transfer ownership of the PNK contract to the kleros POC contract.\n   * @param {string} klerosAddress - Address of Kleros POC contract.\n   * @param {string} account - Address of user.\n   * @returns {object} - The result transaction object.\n   */\n  transferOwnership = async (\n    klerosAddress,\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.transferOwnership(klerosAddress, {\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_TRANSFER_OWNERSHIP)\n    }\n  }\n\n  /**\n   * Get data from PNK contract.\n   * @returns {object} - Data from PNK contract.\n   */\n  getData = async () => {\n    await this.loadContract()\n    const [owner, kleros] = await Promise.all([\n      this.contractInstance.owner(),\n      this.contractInstance.kleros()\n    ])\n\n    return {\n      owner,\n      kleros\n    }\n  }\n}\n\nexport default PinakionPOC\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/PNK/PinakionPOC.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 98,
    "kind": "class",
    "name": "PinakionPOC",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js",
    "static": true,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/PNK/PinakionPOC.js",
    "importStyle": "PinakionPOC",
    "description": "Provides interaction with a PinakionPOC contract deployed on the blockchain.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 99,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#constructor",
    "access": "public",
    "description": "Constructor PinakionPOC.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract (optionnal)."
      }
    ]
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": true,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC.deploy",
    "access": "public",
    "description": "Deploy a new instance of PinakionPOC.",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - 'truffle-contract' Object | err The contract object or error deploy."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "account of user"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "'truffle-contract' Object | err The contract object or error deploy."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "setKleros",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#setKleros",
    "access": "public",
    "description": "Change the kleros contract variable in instance of PinakionPOC.",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "klerosAddress",
        "description": "Address of Kleros POC contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "transferOwnership",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#transferOwnership",
    "access": "public",
    "description": "Transfer ownership of the PNK contract to the kleros POC contract.",
    "lineNumber": 68,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "klerosAddress",
        "description": "Address of Kleros POC contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#getData",
    "access": "public",
    "description": "Get data from PNK contract.",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Data from PNK contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Data from PNK contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "file",
    "name": "src/contracts/implementations/PNK/index.js",
    "content": "import PinakionPOC from './PinakionPOC'\n\nexport { PinakionPOC }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/PNK/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "src/contracts/implementations/RNG/BlockHashRNG.js",
    "content": "import BlockHashRNGArtifact from 'kleros-interaction/build/contracts/BlockHashRNG'\nimport _ from 'lodash'\n\nimport * as ethConstants from '../../../constants/eth'\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\n/**\n * Provides interaction with an instance of BlockHashRNG.\n */\nclass BlockHashRNG extends ContractImplementation {\n  /**\n   * Constructor BlockHashRNG.\n   * @param {object} web3Provider - instance\n   * @param {string} contractAddress - of the contract (optionnal)\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, BlockHashRNGArtifact, contractAddress)\n  }\n\n  /**\n   * BlockHashRNG deploy.\n   * @param {string} account - users account\n   * @param {object} web3Provider - web3 provider object\n   * @returns {object} - truffle-contract Object | err The contract object or error deploy\n   */\n  static deploy = async (account, web3Provider) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      ethConstants.TRANSACTION.VALUE,\n      BlockHashRNGArtifact,\n      web3Provider\n    )\n\n    return contractDeployed\n  }\n}\n\nexport default BlockHashRNG\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/RNG/BlockHashRNG.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "class",
    "name": "BlockHashRNG",
    "memberof": "src/contracts/implementations/RNG/BlockHashRNG.js",
    "static": true,
    "longname": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/RNG/BlockHashRNG.js",
    "importStyle": "BlockHashRNG",
    "description": "Provides interaction with an instance of BlockHashRNG.",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 107,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG#constructor",
    "access": "public",
    "description": "Constructor BlockHashRNG.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract (optionnal)"
      }
    ]
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG",
    "static": true,
    "longname": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG.deploy",
    "access": "public",
    "description": "BlockHashRNG deploy.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - truffle-contract Object | err The contract object or error deploy"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "users account"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The contract object or error deploy"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "file",
    "name": "src/contracts/implementations/RNG/index.js",
    "content": "import BlockHashRNG from './BlockHashRNG'\n\nexport { BlockHashRNG }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/RNG/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 110,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "content": "import arbitrableTransactionArtifact from 'kleros-interaction/build/contracts/ArbitrableTransaction'\nimport _ from 'lodash'\n\nimport * as ethConstants from '../../../constants/eth'\nimport * as contractConstants from '../../../constants/contract'\nimport * as errorConstants from '../../../constants/error'\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\n/**\n * Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.\n */\nclass ArbitrableTransaction extends ContractImplementation {\n  /**\n   * Constructor ArbitrableTransaction.\n   * @param {object} web3Provider instance\n   * @param {string} contractAddress of the contract\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, arbitrableTransactionArtifact, contractAddress)\n  }\n\n  /**\n   * Deploy ArbitrableTransaction.\n   * @param {object} account Ethereum account (default account[0])\n   * @param {number} value funds to be placed in contract\n   * @param {string} hashContract Keccak hash of the plain English contract. (default null hashed)\n   * @param {string} arbitratorAddress The address of the arbitrator contract\n   * @param {number} timeout Time after which a party automatically loose a dispute. (default 3600)\n   * @param {string} partyB The recipient of the transaction. (default account[1])\n   * @param {bytes} arbitratorExtraData Extra data for the arbitrator. (default empty string)\n   * @param {object} web3Provider web3 provider object\n   * @returns {object} truffle-contract Object | err The deployed contract or an error\n   */\n  static deploy = async (\n    account,\n    value = ethConstants.TRANSACTION.VALUE,\n    hashContract,\n    arbitratorAddress,\n    timeout,\n    partyB,\n    arbitratorExtraData = '',\n    web3Provider\n  ) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      value,\n      arbitrableTransactionArtifact,\n      web3Provider,\n      arbitratorAddress,\n      hashContract,\n      timeout,\n      partyB,\n      arbitratorExtraData\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Pay the party B. To be called when the good is delivered or the service rendered.\n   * @param {string} account - Ethereum account (default account[0]).\n   * @param {string} contractAddress - The address of the arbitrator contract.\n   * @returns {object} - The result transaction object.\n   */\n  pay = async (account = this._Web3Wrapper.getAccount(0)) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.pay({\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_SELLER)\n    }\n  }\n\n  /**\n   * Pay the arbitration fee to raise a dispute. To be called by the party A.\n   * @param {string} account - Ethereum account (default account[0]).\n   * @param {number} arbitrationCost - Amount to pay the arbitrator. (default 10000 wei).\n   * @returns {object} - The result transaction object.\n   */\n  payArbitrationFeeByPartyA = async (\n    account = this._Web3Wrapper.getAccount(0),\n    arbitrationCost = 0.15\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.payArbitrationFeeByPartyA({\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS,\n        value: this._Web3Wrapper.toWei(arbitrationCost, 'ether')\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_ARBITRATION_FEE)\n    }\n  }\n\n  /**\n   * Pay the arbitration fee to raise a dispute. To be called by the party B.\n   * @param {string} account Ethereum account (default account[1]).\n   * @param {number} arbitrationCost Amount to pay the arbitrator. (default 10000 wei).\n   * @returns {object} - The result transaction object.\n   */\n  payArbitrationFeeByPartyB = async (\n    account = this._Web3Wrapper.getAccount(1),\n    arbitrationCost = 0.15\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.payArbitrationFeeByPartyB({\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS,\n        value: this._Web3Wrapper.toWei(arbitrationCost, 'ether')\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_ARBITRATION_FEE)\n    }\n  }\n\n  /**\n   * Submit evidence.\n   * @param {string} account ETH address of user.\n   * @param {string} name name of evidence.\n   * @param {string} description description of evidence.\n   * @param {string} url A link to an evidence using its URI.\n   * @returns {string} txHash Hash transaction.\n   */\n  submitEvidence = async (\n    account = this._Web3Wrapper.getAccount(0),\n    name,\n    description = '',\n    url\n  ) => {\n    await this.loadContract()\n\n    const txHashObj = await this.contractInstance.submitEvidence(\n      JSON.stringify(name, description, url),\n      {\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS,\n        value: 0\n      }\n    )\n\n    return txHashObj.tx\n  }\n\n  /**\n   * Call by partyA if partyB is timeout\n   * @param {string} account ETH address of user\n   * @returns {object} The result transaction object.\n   */\n  callTimeOutPartyA = async (account = this._Web3Wrapper.getAccount(0)) => {\n    await this.loadContract()\n\n    const status = (await this.contractInstance.status()).toNumber()\n    const timeout = (await this.contractInstance.timeout()).toNumber()\n    const lastInteraction = (await this.contractInstance.lastInteraction()).toNumber()\n\n    if (status !== contractConstants.STATUS.WAITING_PARTY_B) {\n      throw new Error(errorConstants.CONTRACT_IS_NOT_WAITING_ON_OTHER_PARTY)\n    } else if (Date.now() >= lastInteraction + timeout) {\n      throw new Error(errorConstants.TIMEOUT_NOT_REACHED)\n    }\n\n    try {\n      return this.contractInstance.timeOutByPartyA({\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_CALL_TIMEOUT)\n    }\n  }\n\n  /**\n   * Call by partyB if partyA is timeout.\n   * @param {string} account - ETH address of user.\n   * @param {string} contractAddress - ETH address of contract.\n   * @returns {object} The result transaction object.\n   */\n  callTimeOutPartyB = async (account = this._Web3Wrapper.getAccount(1)) => {\n    await this.loadContract()\n\n    const status = await this.contractInstance.status()\n    const timeout = await this.contractInstance.timeout()\n    const lastInteraction = await this.contractInstance.lastInteraction()\n\n    if (status !== contractConstants.STATUS.WAITING_PARTY_A) {\n      throw new Error(errorConstants.CONTRACT_IS_NOT_WAITING_ON_OTHER_PARTY)\n    } else if (Date.now() >= lastInteraction + timeout) {\n      throw new Error(errorConstants.TIMEOUT_NOT_REACHED)\n    }\n\n    try {\n      return this.contractInstance.timeOutByPartyB({\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_CALL_TIMEOUT)\n    }\n  }\n\n  /**\n   * Get ruling options from dispute via event\n   * @param {string} arbitratorAddress address of arbitrator contract\n   * @param {number} disputeId index of dispute\n   * @returns {object[]} an array of objects that specify the name and value of the resolution option\n   */\n  getRulingOptions = async (arbitratorAddress, disputeId) => {\n    await this.loadContract()\n\n    // fetch dispute resolution options\n    const statusNumber = (await this.contractInstance.status()).toNumber()\n\n    // should this just be !== ?\n    if (statusNumber < contractConstants.STATUS.DISPUTE_CREATED) return []\n\n    // FIXME we should have a block number to start from so we don't have to rip through the entire chain\n    const disputeEvents = await new Promise((resolve, reject) => {\n      this.contractInstance\n        .Dispute({}, { fromBlock: 0, toBlock: 'latest' })\n        .get((error, eventResult) => {\n          if (error) reject(error)\n\n          resolve(eventResult)\n        })\n    })\n\n    const disputeOption = _.filter(disputeEvents, event => {\n      const optionDisputeId = event.args._disputeID.toNumber()\n      // filter by arbitrator address and disputeId\n      return (\n        event.args._arbitrator === arbitratorAddress &&\n        optionDisputeId === disputeId\n      )\n    })\n    // should only be 1 at this point\n    if (disputeOption.length !== 1) return []\n\n    const rulingOptions = disputeOption[0].args._rulingOptions.split(';')\n    let optionIndex = 0\n    const resolutionOptions = rulingOptions.map(option => {\n      optionIndex += 1\n      return {\n        name: option,\n        value: optionIndex\n      }\n    })\n\n    return resolutionOptions\n  }\n\n  /**\n   * Data of the contract\n   * @returns {object} Object Data of the contract.\n   */\n  getData = async () => {\n    await this.loadContract()\n\n    const [\n      arbitrator,\n      extraData,\n      timeout,\n      partyA,\n      partyB,\n      status,\n      arbitratorExtraData,\n      disputeId,\n      partyAFee,\n      partyBFee,\n      lastInteraction,\n      amount\n    ] = await Promise.all([\n      this.contractInstance.arbitrator(),\n      this.contractInstance.arbitratorExtraData(),\n      //  this.contractInstance.hashContract(),\n      this.contractInstance.timeout(),\n      this.contractInstance.partyA(),\n      this.contractInstance.partyB(),\n      this.contractInstance.status(),\n      this.contractInstance.arbitratorExtraData(),\n      this.contractInstance.disputeID(),\n      this.contractInstance.partyAFee(),\n      this.contractInstance.partyBFee(),\n      this.contractInstance.lastInteraction(),\n      this.contractInstance.amount()\n    ])\n\n    return {\n      address: this.getContractAddress(),\n      arbitrator,\n      extraData,\n      timeout: timeout.toNumber(),\n      partyA,\n      partyB,\n      status: status.toNumber(),\n      arbitratorExtraData,\n      disputeId: disputeId.toNumber(),\n      partyAFee: this._Web3Wrapper.fromWei(partyAFee, 'ether'),\n      partyBFee: this._Web3Wrapper.fromWei(partyBFee, 'ether'),\n      lastInteraction: lastInteraction.toNumber(),\n      amount: amount.toNumber()\n    }\n  }\n}\n\nexport default ArbitrableTransaction\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 111,
    "kind": "class",
    "name": "ArbitrableTransaction",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "importStyle": "ArbitrableTransaction",
    "description": "Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.",
    "lineNumber": 13,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 112,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#constructor",
    "access": "public",
    "description": "Constructor ArbitrableTransaction.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract"
      }
    ]
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction.deploy",
    "access": "public",
    "description": "Deploy ArbitrableTransaction.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} truffle-contract Object | err The deployed contract or an error"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account (default account[0])"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "funds to be placed in contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hashContract",
        "description": "Keccak hash of the plain English contract. (default null hashed)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Time after which a party automatically loose a dispute. (default 3600)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "partyB",
        "description": "The recipient of the transaction. (default account[1])"
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorExtraData",
        "description": "Extra data for the arbitrator. (default empty string)"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The deployed contract or an error"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "pay",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#pay",
    "access": "public",
    "description": "Pay the party B. To be called when the good is delivered or the service rendered.",
    "lineNumber": 66,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account (default account[0])."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "The address of the arbitrator contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "payArbitrationFeeByPartyA",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#payArbitrationFeeByPartyA",
    "access": "public",
    "description": "Pay the arbitration fee to raise a dispute. To be called by the party A.",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account (default account[0])."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrationCost",
        "description": "Amount to pay the arbitrator. (default 10000 wei)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "payArbitrationFeeByPartyB",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#payArbitrationFeeByPartyB",
    "access": "public",
    "description": "Pay the arbitration fee to raise a dispute. To be called by the party B.",
    "lineNumber": 111,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account (default account[1])."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrationCost",
        "description": "Amount to pay the arbitrator. (default 10000 wei)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "submitEvidence",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#submitEvidence",
    "access": "public",
    "description": "Submit evidence.",
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} txHash Hash transaction."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "description of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to an evidence using its URI."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "txHash Hash transaction."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "callTimeOutPartyA",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#callTimeOutPartyA",
    "access": "public",
    "description": "Call by partyA if partyB is timeout",
    "lineNumber": 162,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "callTimeOutPartyB",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#callTimeOutPartyB",
    "access": "public",
    "description": "Call by partyB if partyA is timeout.",
    "lineNumber": 193,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "ETH address of contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "getRulingOptions",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#getRulingOptions",
    "access": "public",
    "description": "Get ruling options from dispute via event",
    "lineNumber": 224,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} an array of objects that specify the name and value of the resolution option"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "address of arbitrator contract"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "index of dispute"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "an array of objects that specify the name and value of the resolution option"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#getData",
    "access": "public",
    "description": "Data of the contract",
    "lineNumber": 272,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} Object Data of the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object Data of the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrable/index.js",
    "content": "import ArbitrableTransaction from './ArbitrableTransaction'\n\nexport { ArbitrableTransaction }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrable/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 123,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrator/KlerosPOC.js",
    "content": "import klerosArtifact from 'kleros/build/contracts/KlerosPOC'\nimport _ from 'lodash'\n\nimport * as ethConstants from '../../../constants/eth'\nimport * as errorConstants from '../../../constants/error'\nimport * as arbitratorConstants from '../../../constants/arbitrator'\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\n/**\n * Provides interaction with a KlerosPOC contract on the blockchain.\n */\nclass KlerosPOC extends ContractImplementation {\n  /**\n   * Create new KlerosPOC Implementation.\n   * @param {object} web3Provider - web3 instance.\n   * @param {string} contractAddress - Address of the KlerosPOC contract.\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, klerosArtifact, contractAddress)\n  }\n\n  /**\n   * STATIC: Deploy a KlerosPOC contract on the blockchain.\n   * @param {string} rngAddress address of random number generator contract\n   * @param {string} pnkAddress address of pinakion contract\n   * @param {number[]} timesPerPeriod array of 5 ints indicating the time limit for each period of contract\n   * @param {string} account address of user\n   * @param {number} value amout of eth to send to contract\n   * @param {object} web3Provider web3 provider object NOTE: NOT Kleros Web3Wrapper\n   * @returns {object} truffle-contract Object | err The contract object or error deploy\n   */\n  static deploy = async (\n    rngAddress,\n    pnkAddress,\n    timesPerPeriod = [1, 1, 1, 1, 1],\n    account,\n    value = ethConstants.TRANSACTION.VALUE,\n    web3Provider\n  ) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      value,\n      klerosArtifact,\n      web3Provider,\n      pnkAddress,\n      rngAddress,\n      timesPerPeriod\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Purchase PNK.\n   * @param {string} amount - The number of pinakion to buy.\n   * @param {string} account - The address of the user.\n   * @returns {object} - The result transaction object.\n   */\n  buyPNK = async (amount, account = this._Web3Wrapper.getAccount(0)) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.buyPinakion({\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS,\n        value: this._Web3Wrapper.toWei(amount, 'ether')\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_BUY_PNK)\n    }\n  }\n\n  /**\n   * Get PNK Balances.\n   * @param {string} account - The address of the user.\n   * @returns {object} - Balance information including total PNK balance and activated tokens.\n   */\n  getPNKBalance = async (account = this._Web3Wrapper.getAccount(0)) => {\n    await this.loadContract()\n\n    const juror = await this.contractInstance.jurors(account)\n    if (!juror)\n      throw new Error(\n        errorConstants.ACCOUNT_NOT_A_JUROR_FOR_CONTRACT(\n          account,\n          this.contractAddress\n        )\n      )\n\n    // Total tokens\n    const totalTokens = this._Web3Wrapper.fromWei(juror[0], 'ether')\n\n    // Activated Tokens\n    const currentSession = await this.contractInstance.session()\n    let activatedTokens = 0\n    if (juror[2].toNumber() === currentSession.toNumber())\n      activatedTokens = this._Web3Wrapper.fromWei(\n        juror[4].toNumber() - juror[3].toNumber(),\n        'ether'\n      )\n\n    // Locked Tokens\n    const lockedTokens = this._Web3Wrapper.fromWei(juror[1], 'ether')\n\n    return {\n      tokenBalance: totalTokens,\n      activatedTokens,\n      lockedTokens\n    }\n  }\n\n  /**\n   * Activate Pinakion tokens to be eligible to be a juror.\n   * @param {string} amount - number of tokens to activate.\n   * @param {string} account - address of user.\n   * @returns {object} - PNK balance.\n   */\n  activatePNK = async (\n    amount, // amount in ether\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    try {\n      await this.contractInstance.activateTokens(\n        this._Web3Wrapper.toWei(amount, 'ether'),\n        {\n          from: account,\n          gas: ethConstants.TRANSACTION.GAS\n        }\n      )\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_ACTIVATE_PNK)\n    }\n\n    return this.getPNKBalance(account)\n  }\n\n  /**\n   * Fetch the cost of arbitration.\n   * @param {bytes} contractExtraData - extra data from arbitrable contract.\n   * @returns {number} - The cost of arbitration.\n   */\n  getArbitrationCost = async contractExtraData => {\n    await this.loadContract()\n\n    try {\n      const arbitrationCost = await this.contractInstance.arbitrationCost(\n        contractExtraData\n      )\n\n      return this._Web3Wrapper.fromWei(arbitrationCost, 'ether')\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_ARBITRATION_COST)\n    }\n  }\n\n  /**\n   * Call contract to move on to the next period.\n   * @param {string} account - address of user.\n   * @returns {Promise} - resulting object.\n   */\n  passPeriod = async (account = this._Web3Wrapper.getAccount(0)) => {\n    await this.loadContract()\n\n    try {\n      await this.contractInstance.passPeriod.original({\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS\n      })\n      return this.getData()\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PASS_PERIOD)\n    }\n  }\n\n  /**\n   * Submit votes. Note can only be called during Voting period (Period 2).\n   * @param {number} disputeId - index of the dispute.\n   * @param {number} ruling - int representing the jurors decision.\n   * @param {number[]} votes - int[] of drawn votes for dispute.\n   * @param {string} account - address of user.\n   * @returns {object} - The result transaction object.\n   */\n  submitVotes = async (\n    disputeId,\n    ruling,\n    votes,\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.voteRuling(disputeId, ruling, votes, {\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_SUBMIT_VOTES)\n    }\n  }\n\n  /**\n   * Appeal ruling on dispute.\n   * @param {number} disputeId - Index of the dispute.\n   * @param {string} extraData - Extra data.\n   * @param {string} account - Address of user.\n   * @returns {object} - The result transaction object.\n   */\n  appealRuling = async (\n    disputeId,\n    extraData,\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.appeal(disputeId, extraData, {\n        from: account,\n        value: await this.contractInstance.appealCost(disputeId, extraData),\n        gas: ethConstants.TRANSACTION.GAS\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_APPEAL)\n    }\n  }\n\n  /**\n   * Repartition juror tokens.\n   * @param {number} disputeId - index of the dispute.\n   * @param {string} account - address of user.\n   * @returns {object} - The result transaction object.\n   */\n  repartitionJurorTokens = async (\n    disputeId,\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.oneShotTokenRepartition(disputeId, {\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_REPARTITION_TOKENS)\n    }\n  }\n\n  /**\n   * Execute ruling on dispute\n   * @param {number} disputeId - index of the dispute.\n   * @param {string} account - address of user.\n   * @returns {object} - The result transaction object.\n   */\n  executeRuling = async (\n    disputeId,\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.executeRuling(disputeId, {\n        from: account,\n        gas: ethConstants.TRANSACTION.GAS\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_EXECUTE_RULING)\n    }\n  }\n\n  /**\n   * Get time for a period.\n   * @param {number} periodNumber - int representing period.\n   * @returns {number} - The seconds in the period.\n   */\n  getTimeForPeriod = async periodNumber => {\n    await this.loadContract()\n\n    let timePerPeriod\n\n    try {\n      timePerPeriod = await this.contractInstance.timePerPeriod(periodNumber)\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_TIME_PER_PERIOD)\n    }\n\n    if (timePerPeriod) return timePerPeriod.toNumber()\n\n    throw new Error(errorConstants.PERIOD_OUT_OF_RANGE(periodNumber))\n  }\n\n  /**\n   * Get dispute.\n   * @param {number} disputeId - The index of the dispute.\n   * @returns {object} - The dispute data from the contract.\n   */\n  getDispute = async disputeId => {\n    await this.loadContract()\n\n    try {\n      const dispute = await this.contractInstance.disputes(disputeId)\n      const numberOfAppeals = dispute[2].toNumber()\n      const rulingChoices = dispute[3].toNumber()\n\n      let voteCounters = []\n      let status\n      for (let appeal = 0; appeal <= numberOfAppeals; appeal++) {\n        const voteCounts = []\n        for (let choice = 0; choice <= rulingChoices; choice++)\n          voteCounts.push(\n            this.contractInstance\n              .getVoteCount(disputeId, appeal, choice)\n              .then(v => v.toNumber())\n          )\n        voteCounters.push(voteCounts)\n      }\n\n      ;[voteCounters, status] = await Promise.all([\n        Promise.all(voteCounters.map(voteCounts => Promise.all(voteCounts))),\n        this.contractInstance.disputeStatus(disputeId)\n      ])\n\n      return {\n        arbitratorAddress: this.contractAddress,\n        disputeId,\n        arbitrableContractAddress: dispute[0],\n        firstSession: dispute[1].toNumber(),\n        numberOfAppeals,\n        rulingChoices,\n        initialNumberJurors: dispute[4].toNumber(),\n        arbitrationFeePerJuror: this._Web3Wrapper.fromWei(dispute[5], 'ether'),\n        state: dispute[6].toNumber(),\n        voteCounters,\n        status: status.toNumber()\n      }\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      // console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_DISPUTE)\n    }\n  }\n\n  /**\n   * Get number of jurors for a dispute.\n   * @param {number} disputeId - Index of dispute.\n   * @returns {number} - Number of jurors for a dispute.\n   */\n  getAmountOfJurorsForDispute = async disputeId => {\n    await this.loadContract()\n\n    let amountOfJurors\n\n    try {\n      amountOfJurors = await this.contractInstance.amountJurors(disputeId)\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_AMOUNT_OF_JURORS)\n    }\n\n    if (amountOfJurors) return amountOfJurors.toNumber()\n\n    throw new Error(errorConstants.DISPUTE_DOES_NOT_EXIST)\n  }\n\n  /**\n   * Get number of jurors for a dispute.\n   * @param {number} disputeId - Index of dispute.\n   * @param {number} draw - Int for draw.\n   * @param {string} jurorAddress - Address of juror.\n   * @returns {bool} - `true` indicates juror has a vote for draw, `false` indicates they do not.\n   */\n  isJurorDrawnForDispute = async (\n    disputeId,\n    draw,\n    jurorAddress = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    const isDrawn = await this.contractInstance.isDrawn(\n      disputeId,\n      jurorAddress,\n      draw\n    )\n\n    return isDrawn\n  }\n\n  /**\n   * Can juror currently rule in dispute.\n   * @param {number} disputeId - index of dispute.\n   * @param {int[]} draws - voting positions for dispute.\n   * @param {string} account - address of user.\n   * @returns {bool} - Boolean indicating if juror can rule or not.\n   */\n  canRuleDispute = async (disputeId, draws, account) => {\n    await this.loadContract()\n\n    const validDraws = await this.contractInstance.validDraws(\n      account,\n      disputeId,\n      draws\n    )\n    const lastRuling = (await this.contractInstance.getLastSessionVote(\n      disputeId,\n      account\n    )).toNumber()\n    const currentSession = await this.getSession(this.contractAddress)\n\n    return validDraws && lastRuling !== currentSession\n  }\n\n  /**\n   * Get number of jurors for a dispute.\n   * @param {number} disputeId - Index of dispute.\n   * @param {number} appeal - Index of appeal.\n   * @returns {number} - Int indicating the ruling of the dispute.\n   */\n  currentRulingForDispute = async (disputeId, appeal) => {\n    await this.loadContract()\n\n    const ruling = await this.contractInstance.getWinningChoice(\n      disputeId,\n      appeal\n    )\n\n    return ruling.toNumber()\n  }\n\n  /**\n   * Get current period of the contract\n   * @returns {number} - Int indicating the period.\n   */\n  getPeriod = async () => {\n    await this.loadContract()\n\n    const currentPeriod = await this.contractInstance.period()\n\n    return currentPeriod.toNumber()\n  }\n\n  /**\n   * Get current session of the contract.\n   * @returns {number} - Int indicating the session.\n   */\n  getSession = async () => {\n    await this.loadContract()\n\n    const currentSession = await this.contractInstance.session()\n\n    return currentSession.toNumber()\n  }\n\n  /**\n   * Get disputes from Kleros contract.\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Array of disputes.\n   */\n  getDisputesForJuror = async account => {\n    await this.loadContract()\n\n    // contract data\n    const openDisputes = await this.getOpenDisputesForSession()\n\n    const disputes = await Promise.all(\n      openDisputes.map(async disputeData => {\n        const draws = await this.getDrawsForJuror(\n          disputeData.disputeId,\n          account\n        )\n        disputeData.appealDraws = disputeData.appealDraws || []\n        disputeData.appealDraws[disputeData.numberOfAppeals] = draws\n\n        return disputeData\n      })\n    )\n\n    return disputes\n  }\n\n  /**\n   * Fetch the votes a juror has in a dispute.\n   * @param {number} disputeId - ID of the dispute.\n   * @param {string} account - Potential jurors address.\n   * @returns {number[]} - Array of integers indicating the draw.\n   */\n  getDrawsForJuror = async (disputeId, account) => {\n    await this.loadContract()\n\n    const numberOfJurors = await this.getAmountOfJurorsForDispute(disputeId)\n    const draws = []\n    for (let draw = 1; draw <= numberOfJurors; draw++) {\n      const isJuror = await this.isJurorDrawnForDispute(\n        disputeId,\n        draw,\n        account\n      )\n      if (isJuror) {\n        draws.push(draw)\n      }\n    }\n    return draws\n  }\n\n  /** Get all disputes that are active this session.\n   * @returns {int[]} - array of active disputeId\n   */\n  getOpenDisputesForSession = async () => {\n    await this.loadContract()\n\n    const currentSession = await this.getSession()\n    const openDisputes = []\n\n    let disputeId = 0\n    let dispute\n    while (1) {\n      // Iterate over all the disputes\n      // TODO: Implement a more performant solution\n      try {\n        dispute = await this.getDispute(disputeId)\n      } catch (err) {\n        // Dispute out of range, break\n        if (err.message === errorConstants.UNABLE_TO_FETCH_DISPUTE) break\n        console.error(err)\n        throw err\n      }\n\n      // Dispute has no arbitrable contract, break\n      if (dispute.arbitrableContractAddress === ethConstants.NULL_ADDRESS) break\n\n      // If dispute is in the current session, add it to the result array\n      if (dispute.firstSession + dispute.numberOfAppeals === currentSession)\n        openDisputes.push(dispute)\n\n      // Advance to the next dispute\n      disputeId++\n    }\n\n    return openDisputes\n  }\n\n  /**\n   * Gets the deadline for an arbitrator's period, which is also the deadline for all its disputes.\n   * @param {number} [period=PERIODS.VOTE] - The period to get the deadline for.\n   * @returns {number} - epoch timestamp\n   */\n  getDeadlineForOpenDispute = async (\n    period = arbitratorConstants.PERIOD.VOTE\n  ) => {\n    await this.loadContract()\n\n    // Get arbitrator data\n    const lastPeriodChange = (await this.contractInstance.lastPeriodChange()).toNumber()\n\n    // Last period change + current period duration = deadline\n    const result =\n      1000 * (lastPeriodChange + (await this.getTimeForPeriod(period)))\n\n    return result\n  }\n\n  /**\n   * Get data from Kleros contract.\n   * TODO split these into their own methods for more flexability and speed\n   * @returns {object} - Data for kleros POC from contract.\n   */\n  getData = async () => {\n    await this.loadContract()\n\n    const [\n      pinakionContractAddress,\n      rngContractAddress,\n      period,\n      session,\n      lastPeriodChange\n    ] = await Promise.all([\n      this.contractInstance.pinakion(),\n      this.contractInstance.rng(),\n      this.contractInstance.period(),\n      this.contractInstance.session(),\n      this.contractInstance.lastPeriodChange()\n    ])\n\n    return {\n      pinakionContractAddress,\n      rngContractAddress,\n      period: period.toNumber(),\n      session: session.toNumber(),\n      lastPeriodChange: lastPeriodChange.toNumber()\n    }\n  }\n}\n\nexport default KlerosPOC\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrator/KlerosPOC.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 124,
    "kind": "class",
    "name": "KlerosPOC",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrator/KlerosPOC.js",
    "importStyle": "KlerosPOC",
    "description": "Provides interaction with a KlerosPOC contract on the blockchain.",
    "lineNumber": 13,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 125,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#constructor",
    "access": "public",
    "description": "Create new KlerosPOC Implementation.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of the KlerosPOC contract."
      }
    ]
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": true,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC.deploy",
    "access": "public",
    "description": "STATIC: Deploy a KlerosPOC contract on the blockchain.",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} truffle-contract Object | err The contract object or error deploy"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rngAddress",
        "description": "address of random number generator contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pnkAddress",
        "description": "address of pinakion contract"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "timesPerPeriod",
        "description": "array of 5 ints indicating the time limit for each period of contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "amout of eth to send to contract"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object NOTE: NOT Kleros Web3Wrapper"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The contract object or error deploy"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "buyPNK",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#buyPNK",
    "access": "public",
    "description": "Purchase PNK.",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "The number of pinakion to buy."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "getPNKBalance",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getPNKBalance",
    "access": "public",
    "description": "Get PNK Balances.",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Balance information including total PNK balance and activated tokens."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Balance information including total PNK balance and activated tokens."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "activatePNK",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#activatePNK",
    "access": "public",
    "description": "Activate Pinakion tokens to be eligible to be a juror.",
    "lineNumber": 120,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - PNK balance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "number of tokens to activate."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "PNK balance."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "getArbitrationCost",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getArbitrationCost",
    "access": "public",
    "description": "Fetch the cost of arbitration.",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The cost of arbitration."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "contractExtraData",
        "description": "extra data from arbitrable contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The cost of arbitration."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "passPeriod",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#passPeriod",
    "access": "public",
    "description": "Call contract to move on to the next period.",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - resulting object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "resulting object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "submitVotes",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#submitVotes",
    "access": "public",
    "description": "Submit votes. Note can only be called during Voting period (Period 2).",
    "lineNumber": 190,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ruling",
        "description": "int representing the jurors decision."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "votes",
        "description": "int[] of drawn votes for dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "member",
    "name": "appealRuling",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#appealRuling",
    "access": "public",
    "description": "Appeal ruling on dispute.",
    "lineNumber": 216,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "Index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "extraData",
        "description": "Extra data."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "member",
    "name": "repartitionJurorTokens",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#repartitionJurorTokens",
    "access": "public",
    "description": "Repartition juror tokens.",
    "lineNumber": 241,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "executeRuling",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#executeRuling",
    "access": "public",
    "description": "Execute ruling on dispute",
    "lineNumber": 264,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "getTimeForPeriod",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getTimeForPeriod",
    "access": "public",
    "description": "Get time for a period.",
    "lineNumber": 286,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The seconds in the period."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "periodNumber",
        "description": "int representing period."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The seconds in the period."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "getDispute",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getDispute",
    "access": "public",
    "description": "Get dispute.",
    "lineNumber": 308,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The dispute data from the contract."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "The index of the dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The dispute data from the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "getAmountOfJurorsForDispute",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getAmountOfJurorsForDispute",
    "access": "public",
    "description": "Get number of jurors for a dispute.",
    "lineNumber": 359,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Number of jurors for a dispute."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "Index of dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Number of jurors for a dispute."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "isJurorDrawnForDispute",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#isJurorDrawnForDispute",
    "access": "public",
    "description": "Get number of jurors for a dispute.",
    "lineNumber": 383,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{bool} - `true` indicates juror has a vote for draw, `false` indicates they do not."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "Index of dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "draw",
        "description": "Int for draw."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "jurorAddress",
        "description": "Address of juror."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": "`true` indicates juror has a vote for draw, `false` indicates they do not."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "canRuleDispute",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#canRuleDispute",
    "access": "public",
    "description": "Can juror currently rule in dispute.",
    "lineNumber": 406,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{bool} - Boolean indicating if juror can rule or not."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "index of dispute."
      },
      {
        "nullable": null,
        "types": [
          "int[]"
        ],
        "spread": false,
        "optional": false,
        "name": "draws",
        "description": "voting positions for dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": "Boolean indicating if juror can rule or not."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "currentRulingForDispute",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#currentRulingForDispute",
    "access": "public",
    "description": "Get number of jurors for a dispute.",
    "lineNumber": 429,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Int indicating the ruling of the dispute."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "Index of dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "Index of appeal."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Int indicating the ruling of the dispute."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "getPeriod",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getPeriod",
    "access": "public",
    "description": "Get current period of the contract",
    "lineNumber": 444,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Int indicating the period."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Int indicating the period."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "getSession",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getSession",
    "access": "public",
    "description": "Get current session of the contract.",
    "lineNumber": 456,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Int indicating the session."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Int indicating the session."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "getDisputesForJuror",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getDisputesForJuror",
    "access": "public",
    "description": "Get disputes from Kleros contract.",
    "lineNumber": 469,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of disputes."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of disputes."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "getDrawsForJuror",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getDrawsForJuror",
    "access": "public",
    "description": "Fetch the votes a juror has in a dispute.",
    "lineNumber": 497,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number[]} - Array of integers indicating the draw."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "ID of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Potential jurors address."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "Array of integers indicating the draw."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "getOpenDisputesForSession",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getOpenDisputesForSession",
    "access": "public",
    "description": "Get all disputes that are active this session.",
    "lineNumber": 518,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{int[]} - array of active disputeId"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "int[]"
      ],
      "spread": false,
      "description": "array of active disputeId"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "member",
    "name": "getDeadlineForOpenDispute",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getDeadlineForOpenDispute",
    "access": "public",
    "description": "Gets the deadline for an arbitrator's period, which is also the deadline for all its disputes.",
    "lineNumber": 557,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - epoch timestamp"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "PERIODS.VOTE",
        "defaultRaw": "PERIODS.VOTE",
        "name": "period",
        "description": "The period to get the deadline for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "epoch timestamp"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#getData",
    "access": "public",
    "description": "Get data from Kleros contract.\nTODO split these into their own methods for more flexability and speed",
    "lineNumber": 577,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Data for kleros POC from contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Data for kleros POC from contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrator/index.js",
    "content": "import KlerosPOC from './KlerosPOC'\n\nexport { KlerosPOC }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrator/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 150,
    "kind": "file",
    "name": "src/contracts/implementations/index.js",
    "content": "import * as arbitrator from './arbitrator'\nimport * as arbitrable from './arbitrable'\nimport * as PNK from './PNK'\nimport * as RNG from './RNG'\n\nexport { arbitrator, arbitrable, PNK, RNG }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 151,
    "kind": "file",
    "name": "src/contracts/index.js",
    "content": "import * as abstractions from './abstractions'\nimport * as implementations from './implementations'\n\nexport { abstractions, implementations }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 152,
    "kind": "file",
    "name": "src/index.js",
    "content": "import Kleros from './kleros.js'\n\nexport { Kleros }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 153,
    "kind": "file",
    "name": "src/kleros.js",
    "content": "import isRequired from './utils/isRequired'\nimport Web3Wrapper from './utils/Web3Wrapper'\nimport StoreProviderWrapper from './utils/StoreProviderWrapper'\nimport * as contracts from './contracts'\nimport * as resources from './resources'\nimport EventListener from './utils/EventListener'\n\n/**\n * The Kleros Api provides access to the full suite of functionality. It will initialize\n * contract instances for you when possible and creates an object that you can use to\n * call all of the other api modules. If you are only going to be interacting with\n * specific apis, or you don't want certain functionality such as the off chain store,\n * you might find it easier to initialze a specific instance of the api you want.\n */\nclass Kleros {\n  web3Wrapper = {}\n\n  storeWrapper = {}\n\n  eventListener = null\n\n  /**\n   * Instantiates a new Kelros instance that provides the public interface\n   * to Kleros contracts and library. All params are required. To use an individual\n   * portion of the API import a class and initialize it yourself.\n   * @param {string} ethereumProvider - The Web3.js Provider instance you would like the\n   *                 Kleros.js library to use for interacting with the\n   *                 Ethereum network.\n   * @param {string} storeUri - The storage provider uri used to\n   *                      get metadata from the cloud for the UI. e.g. Kleros-Store,\n   *                      IPFS, Swarm etc.\n   * @param {string} arbitratorAddress - Address of the arbitrator contract we should\n   *                 use when initializing KlerosPOC\n   * @param {string} arbitrableContractAddress - Address of the arbitrator contract we should\n   *                 use when initializing KlerosPOC\n   * @param {string} authToken - Signed token cooresponding to the user profile address.\n   */\n  constructor(\n    ethereumProvider = isRequired('ethereumProvider'),\n    storeUri = isRequired('storeUri'),\n    arbitratorAddress,\n    arbitrableContractAddress,\n    authToken\n  ) {\n    // NOTE we default to KlerosPOC and ArbitrableTransaction\n    const _klerosPOC = new contracts.implementations.arbitrator.KlerosPOC(\n      ethereumProvider,\n      arbitratorAddress\n    )\n    const _arbitrableTransaction = new contracts.implementations.arbitrable.ArbitrableTransaction(\n      ethereumProvider,\n      arbitrableContractAddress\n    )\n\n    // **************************** //\n    // *   INITIALIZED CLASSES    * //\n    // **************************** //\n    // KLEROS WRAPPERS\n    this.web3Wrapper = new Web3Wrapper(ethereumProvider)\n    this.storeWrapper = new StoreProviderWrapper(storeUri, authToken)\n    // ARBITRATOR\n    this.arbitrator = new contracts.abstractions.Arbitrator(\n      _klerosPOC,\n      this.storeWrapper\n    )\n    // ARBITRABLE CONTRACTS\n    this.arbitrable = new contracts.abstractions.Arbitrable(\n      _arbitrableTransaction,\n      this.storeWrapper\n    )\n    // DISPUTES\n    this.disputes = new resources.Disputes(\n      this.arbitrator,\n      this.arbitrable,\n      this.storeWrapper\n    )\n    // NOTIFICATIONS\n    this.notifications = new resources.Notifications(\n      this.arbitrator,\n      this.arbitrable,\n      this.storeWrapper\n    )\n    // AUTH\n    this.auth = new resources.Auth(this.web3Wrapper, this.storeWrapper)\n  }\n\n  /**\n   * Set a new arbitrable contract for Kleros instance of arbitrableContracts\n   * @param {string} contractAddress - Address of arbitrable contract\n   */\n  setArbitrableContractAddress = contractAddress => {\n    this.arbitrable.setContractInstance(contractAddress)\n  }\n\n  /**\n   * Bootstraps an EventListener and adds all Kleros handlers for event logs. Use\n   * this if you want to watch the chain for notifications, or are using the off chain\n   * store for metadata.\n   * @param {string} account Address of the user\n   * @param {function} callback The function to be called once a notification\n   */\n  watchForEvents = async (\n    account,\n    callback // for notification callback\n  ) => {\n    // stop current event listeners\n    if (this.eventListener) {\n      this.eventListener.stopWatchingForEvents()\n    }\n    // reinitialize with current arbitrator contract instance\n    this.eventListener = new EventListener([this.arbitrator])\n    // add handlers for notifications\n    this.notifications.registerArbitratorNotifications(\n      account,\n      this.eventListener,\n      callback\n    )\n    // add handlers for event driven store updates\n    this.disputes.registerStoreUpdateEventListeners(account, this.eventListener)\n    // fetch last block for user\n    const fromBlock = await this.storeWrapper.getLastBlock(account)\n    // start event listener\n    this.eventListener.watchForEvents(fromBlock)\n  }\n\n  /**\n   * Stop watching for events on the Arbitrator initialized in the Kleros Instance.\n   */\n  stopWatchingForEvents = () => {\n    this.eventListener.stopWatchingForEvents(this.arbitrator)\n  }\n\n  /**\n   * Sets the store provider uri for all higher level apis in the Kleros Instance.\n   * @param {string} storeUri - The URI that the store provider will use\n   */\n  setStoreProvider = storeUri => {\n    this.storeWrapper = new StoreProviderWrapper(storeUri)\n\n    this.disputes.setStoreProviderInstance(this.storeWrapper)\n    this.arbitrable.setStoreProviderInstance(this.storeWrapper)\n    this.arbitrator.setStoreProviderInstance(this.storeWrapper)\n    this.notifications.setStoreProviderInstance(this.storeWrapper)\n    this.auth.setStoreProviderInstance(this.storeWrapper)\n  }\n}\n\nexport default Kleros\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/kleros.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 154,
    "kind": "class",
    "name": "Kleros",
    "memberof": "src/kleros.js",
    "static": true,
    "longname": "src/kleros.js~Kleros",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/kleros.js",
    "importStyle": "Kleros",
    "description": "The Kleros Api provides access to the full suite of functionality. It will initialize\ncontract instances for you when possible and creates an object that you can use to\ncall all of the other api modules. If you are only going to be interacting with\nspecific apis, or you don't want certain functionality such as the off chain store,\nyou might find it easier to initialze a specific instance of the api you want.",
    "lineNumber": 15,
    "interface": false
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "web3Wrapper",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#web3Wrapper",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "member",
    "name": "storeWrapper",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#storeWrapper",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "member",
    "name": "eventListener",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#eventListener",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/kleros.js~Kleros",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/kleros.js~Kleros#constructor",
    "access": "public",
    "description": "Instantiates a new Kelros instance that provides the public interface\nto Kleros contracts and library. All params are required. To use an individual\nportion of the API import a class and initialize it yourself.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ethereumProvider",
        "description": "The Web3.js Provider instance you would like the\n                Kleros.js library to use for interacting with the\n                Ethereum network."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "storeUri",
        "description": "The storage provider uri used to\n                     get metadata from the cloud for the UI. e.g. Kleros-Store,\n                     IPFS, Swarm etc."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "Address of the arbitrator contract we should\n                use when initializing KlerosPOC"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableContractAddress",
        "description": "Address of the arbitrator contract we should\n                use when initializing KlerosPOC"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "authToken",
        "description": "Signed token cooresponding to the user profile address."
      }
    ]
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "arbitrator",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#arbitrator",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "arbitrable",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#arbitrable",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "disputes",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#disputes",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "notifications",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#notifications",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "auth",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#auth",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "setArbitrableContractAddress",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#setArbitrableContractAddress",
    "access": "public",
    "description": "Set a new arbitrable contract for Kleros instance of arbitrableContracts",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of arbitrable contract"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "member",
    "name": "watchForEvents",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#watchForEvents",
    "access": "public",
    "description": "Bootstraps an EventListener and adds all Kleros handlers for event logs. Use\nthis if you want to watch the chain for notifications, or are using the off chain\nstore for metadata.",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of the user"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The function to be called once a notification"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "member",
    "name": "stopWatchingForEvents",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#stopWatchingForEvents",
    "access": "public",
    "description": "Stop watching for events on the Arbitrator initialized in the Kleros Instance.",
    "lineNumber": 129,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "setStoreProvider",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#setStoreProvider",
    "access": "public",
    "description": "Sets the store provider uri for all higher level apis in the Kleros Instance.",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "storeUri",
        "description": "The URI that the store provider will use"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "file",
    "name": "src/resources/Auth.js",
    "content": "import Personal from 'web3-eth-personal'\n\nimport isRequired from '../utils/isRequired'\nimport { UNABLE_TO_SIGN_TOKEN } from '../constants/error'\n\nclass Auth {\n  constructor(\n    web3Wrapper = isRequired('web3Wrapper'),\n    storeProviderInstance = isRequired('storeProviderInstance')\n  ) {\n    this._Web3Wrapper = web3Wrapper\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  /**\n   * Set an auth token in the Store Provider. Call this instead of validateNewAuthToken\n   * if you have a signed token saved.\n   * @param {string} token - Hex representation of signed token.\n   */\n  setAuthToken = token => {\n    this._StoreProviderInstance.setAuthToken(token)\n  }\n\n  /**\n   * Validate a new auth token. Note if you validate a new token old signed tokens\n   * will not longer be valid regardless of their expiration time.\n   * @param {string} userAddress - Address of the user profile\n   * @returns {string} Signed token for future use.\n   */\n  getNewAuthToken = async userAddress => {\n    const unsignedToken = (await this._StoreProviderInstance.newAuthToken(\n      userAddress\n    )).unsignedToken\n\n    const signedToken = await this.signMessage(userAddress, unsignedToken)\n    // make sure token is valid\n    if (!await this.validateAuthToken(userAddress, signedToken))\n      throw new Error(UNABLE_TO_SIGN_TOKEN)\n\n    return signedToken\n  }\n\n  /**\n   * Sign a message with your private key. Uses web3 1.0 personal sign\n   * @param {string} userAddress - The address with which we want to sign the message\n   * @param {string} data - Hex encoded data to sign\n   * @returns {string} signed data\n   */\n  signMessage = (userAddress, data) => {\n    const ethPersonal = new Personal(this._Web3Wrapper.getProvider())\n    return new Promise((resolve, reject) => {\n      ethPersonal.sign(data, userAddress, (error, result) => {\n        if (error) reject(error)\n\n        resolve(result)\n      })\n    })\n  }\n\n  /**\n   * Validate an auth token.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} authToken - Token to check.\n   * @returns {Promise} resolves to True if token is valid.\n   */\n  validateAuthToken = (userAddress, authToken) =>\n    this._StoreProviderInstance.isTokenValid(userAddress, authToken)\n}\n\nexport default Auth\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/Auth.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 173,
    "kind": "class",
    "name": "Auth",
    "memberof": "src/resources/Auth.js",
    "static": true,
    "longname": "src/resources/Auth.js~Auth",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/resources/Auth.js",
    "importStyle": "Auth",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 174,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/resources/Auth.js~Auth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/resources/Auth.js~Auth#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "_Web3Wrapper",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#_Web3Wrapper",
    "access": "private",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "_StoreProviderInstance",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#_StoreProviderInstance",
    "access": "private",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "member",
    "name": "setAuthToken",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#setAuthToken",
    "access": "public",
    "description": "Set an auth token in the Store Provider. Call this instead of validateNewAuthToken\nif you have a signed token saved.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "token",
        "description": "Hex representation of signed token."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "getNewAuthToken",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#getNewAuthToken",
    "access": "public",
    "description": "Validate a new auth token. Note if you validate a new token old signed tokens\nwill not longer be valid regardless of their expiration time.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} Signed token for future use."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of the user profile"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Signed token for future use."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "name": "signMessage",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#signMessage",
    "access": "public",
    "description": "Sign a message with your private key. Uses web3 1.0 personal sign",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} signed data"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address with which we want to sign the message"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Hex encoded data to sign"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "signed data"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "validateAuthToken",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#validateAuthToken",
    "access": "public",
    "description": "Validate an auth token.",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} resolves to True if token is valid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "authToken",
        "description": "Token to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "resolves to True if token is valid."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "file",
    "name": "src/resources/Disputes.js",
    "content": "import _ from 'lodash'\n\nimport * as arbitratorConstants from '../constants/arbitrator'\nimport * as disputeConstants from '../constants/dispute'\nimport isRequired from '../utils/isRequired'\n\n/**\n * Disputes API. Provides cross arbitrator and arbitrable contracts functionality.\n * Requires Store Provider to be set.\n */\nclass Disputes {\n  constructor(\n    arbitratorInstance = isRequired('arbitratorInstance'),\n    arbitrableInstance = isRequired('arbitrableInstance'),\n    storeProviderInstance = isRequired('storeProviderInstance')\n  ) {\n    this._ArbitratorInstance = arbitratorInstance\n    this._ArbitrableInstance = arbitrableInstance\n    this._StoreProviderInstance = storeProviderInstance\n  }\n  /**\n   * Set arbitrator instance.\n   * @param {object} arbitratorInstance - instance of an arbitrator contract.\n   */\n  setArbitratorInstance = arbitratorInstance => {\n    this._ArbitratorInstance = arbitratorInstance\n  }\n  /**\n   * Set arbitrable instance.\n   * @param {object} arbitrableInstance - instance of an arbitrable contract.\n   */\n  setArbitrableInstance = arbitrableInstance => {\n    this._ArbitrableInstance = arbitrableInstance\n  }\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  // **************************** //\n  // *         Events           * //\n  // **************************** //\n\n  /**\n   * Method to register all dispute handlers to an EventListener.\n   * @param {string} account - The address of the user.\n   * @param {object} eventListener - The EventListener instance. See utils/EventListener.js.\n   */\n  registerStoreUpdateEventListeners = (\n    account = isRequired('account'),\n    eventListener = isRequired('eventListener')\n  ) => {\n    const eventHandlerMap = {\n      DisputeCreation: [this._storeNewDisputeHandler],\n      TokenShift: [this._storeTokensMovedForJuror],\n      NewPeriod: [this._storeDisputeRuledAtTimestamp, this._storeAppealDeadline]\n    }\n\n    for (let event in eventHandlerMap) {\n      if (eventHandlerMap.hasOwnProperty(event)) {\n        eventHandlerMap[event].forEach(handler => {\n          eventListener.addEventHandler(this._ArbitratorInstance, event, args =>\n            handler(args, account)\n          )\n        })\n      }\n    }\n  }\n\n  /**\n   * Event listener handler that stores dispute in store upon creation\n   * @param {string} event - The event log.\n   * @param {string} account - Account of user to update store data for\n   */\n  _storeNewDisputeHandler = async (event, account) => {\n    // There is no need to handle this event if we are not using the store\n    const disputeId = event.args._disputeID.toNumber()\n\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n    // arbitrator data\n    const disputeData = await this._ArbitratorInstance.getDispute(disputeId)\n    // arbitrable contract data\n    await this._ArbitrableInstance.setContractInstance(\n      disputeData.arbitrableContractAddress\n    )\n\n    const arbitrableContractData = await this._ArbitrableInstance.getData(\n      account\n    )\n    if (\n      account === arbitrableContractData.partyA ||\n      account === arbitrableContractData.partyB\n    ) {\n      // timestamp\n      const blockTimestamp = (await this._ArbitratorInstance.getBlock(\n        event.blockNumber\n      )).timestamp\n\n      // Check if dispute has already been stored. This can happen if there was an appeal\n      const storedDispute = this._StoreProviderInstance.getDisputeDataForUser(\n        arbitrableContractData.partyA,\n        arbitratorAddress,\n        disputeId\n      )\n      const appealCreatedAt = storedDispute.appealCreatedAt || []\n      appealCreatedAt[disputeData.numberOfAppeals] = blockTimestamp * 1000\n\n      await this._StoreProviderInstance.updateDisputeProfile(\n        account,\n        arbitratorAddress,\n        disputeId,\n        {\n          contractAddress: disputeData.arbitrableContractAddress,\n          partyA: arbitrableContractData.partyA,\n          partyB: arbitrableContractData.partyB,\n          appealCreatedAt\n        }\n      )\n    }\n  }\n\n  /**\n   * Event listener handler that add or substract the stored Net PNK won/lost for a juror.\n   * @param {string} event - The event log.\n   * @param {string} account - The account.\n   */\n  _storeTokensMovedForJuror = async (event, account) => {\n    const disputeId = event.args._disputeID.toNumber()\n    const address = event.args._account\n    const amountShift = event.args._amount.toNumber()\n    // juror won/lost tokens\n    if (address === account) {\n      const userProfile = await this._StoreProviderInstance.setUpUserProfile(\n        account\n      )\n      const contractAddress = this._ArbitratorInstance.getContractAddress()\n      const disputeIndex = _.findIndex(\n        userProfile.disputes,\n        dispute =>\n          dispute.disputeId === disputeId &&\n          dispute.arbitratorAddress === contractAddress\n      )\n\n      // if dispute is not in store ignore\n      if (disputeIndex < 0) return\n      const dispute = userProfile.disputes[disputeIndex]\n      await this._StoreProviderInstance.updateDisputeProfile(\n        account,\n        dispute.arbitratorAddress,\n        dispute.disputeId,\n        {\n          netPNK: (dispute.netPNK || 0) + amountShift\n        }\n      )\n    }\n  }\n\n  /**\n   * Event listener handler that updates ruled at timestamp\n   * @param {object} event - The event log.\n   * @param {string} account - The users eth account.\n   */\n  _storeDisputeRuledAtTimestamp = async (event, account) => {\n    // we fetch the current period in case we are consuming old events from previous sessions\n    const newPeriod = await this._ArbitratorInstance.getPeriod()\n    // send appeal possible notifications\n    if (newPeriod === arbitratorConstants.PERIOD.APPEAL) {\n      const disputes = await this._StoreProviderInstance.getDisputes(account)\n      const openDisputes = await this._ArbitratorInstance.getOpenDisputesForSession()\n      const contractAddress = this._ArbitratorInstance.getContractAddress()\n\n      await Promise.all(\n        openDisputes.map(async openDispute => {\n          const disputeIndex = _.findIndex(\n            disputes,\n            dispute =>\n              dispute.disputeId === openDispute.disputeId &&\n              dispute.arbitratorAddress === contractAddress\n          )\n          if (disputeIndex >= 0) {\n            // get ruledAt from block timestamp\n            const blockNumber = event.blockNumber\n            const blockTimestamp = (await this._ArbitratorInstance.getBlock(\n              blockNumber\n            )).timestamp\n\n            const appealRuledAt = disputes[disputeIndex].appealRuledAt || []\n            appealRuledAt[openDispute.numberOfAppeals] = blockTimestamp * 1000\n\n            this._StoreProviderInstance.updateDisputeProfile(\n              account,\n              contractAddress,\n              openDispute.disputeId,\n              {\n                appealRuledAt\n              }\n            )\n          }\n        })\n      )\n    }\n  }\n\n  /**\n   * Event listener handler that sets the deadline for an appeal\n   * @param {object} _ - The event log. Unused in function.\n   * @param {string} account - The users eth account.\n   */\n  _storeAppealDeadline = async (_, account) => {\n    // we fetch the current period in case we are consuming old events from previous sessions\n    const newPeriod = await this._ArbitratorInstance.getPeriod()\n    // send appeal possible notifications\n    if (newPeriod === arbitratorConstants.PERIOD.VOTE) {\n      const disputes = await this._StoreProviderInstance.getDisputes(account)\n      // contract data\n      const openDisputes = await this._ArbitratorInstance.getOpenDisputesForSession()\n      const contractAddress = this._ArbitratorInstance.getContractAddress()\n      await Promise.all(\n        openDisputes.map(async openDispute => {\n          const disputeIndex = _.findIndex(\n            disputes,\n            dispute =>\n              dispute.disputeId === openDispute.disputeId &&\n              dispute.arbitratorAddress === contractAddress\n          )\n          if (disputeIndex >= 0) {\n            const deadline = await this._ArbitratorInstance.getDeadlineForOpenDispute()\n            const appealDeadlines = disputes[disputeIndex].appealDeadlines || []\n            appealDeadlines[openDispute.numberOfAppeals] = deadline\n\n            this._StoreProviderInstance.updateDisputeProfile(\n              account,\n              contractAddress,\n              openDispute.disputeId,\n              {\n                appealDeadlines\n              }\n            )\n          }\n        })\n      )\n    }\n  }\n\n  // **************************** //\n  // *          Public          * //\n  // **************************** //\n  /**\n   * Fetch the shared dispute data from the store.\n   * @param {string} disputeId - The index of the dispute.\n   * @returns {Promise} The dispute data in the store.\n   */\n  getDisputeFromStore = disputeId => {\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n    return this._StoreProviderInstance.getDispute(arbitratorAddress, disputeId)\n  }\n\n  /**\n   * Get data for a dispute. This method provides data from the store as well as both\n   * arbitrator and arbitrable contracts. Used to get all relevant data on a dispute.\n   * @param {number} disputeId - The dispute's ID.\n   * @param {string} account - The juror's address.\n   * @returns {object} - Data object for the dispute that uses data from the contract and the store.\n   */\n  getDataForDispute = async (disputeId, account) => {\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n    // Get dispute data from contract. Also get the current session and period.\n    const [dispute, period, session] = await Promise.all([\n      this._ArbitratorInstance.getDispute(disputeId),\n      this._ArbitratorInstance.getPeriod(),\n      this._ArbitratorInstance.getSession()\n    ])\n\n    // Get arbitrable contract data and evidence\n    const arbitrableContractAddress = dispute.arbitrableContractAddress\n    await this._ArbitrableInstance.setContractInstance(\n      arbitrableContractAddress\n    )\n    const [arbitrableContractData, evidence] = await Promise.all([\n      this._ArbitrableInstance.getData(account),\n      this._ArbitrableInstance.getEvidenceForArbitrableContract(\n        arbitrableContractAddress\n      )\n    ])\n    const contractStoreData = await this._StoreProviderInstance.getContractByAddress(\n      arbitrableContractData.partyA,\n      arbitrableContractAddress\n    )\n\n    // Get dispute data from the store\n    let appealDraws = []\n    let appealCreatedAt = []\n    let appealDeadlines = []\n    let appealRuledAt = []\n    let netPNK = 0\n    try {\n      const userData = await this._StoreProviderInstance.getDisputeDataForUser(\n        account,\n        arbitratorAddress,\n        disputeId\n      )\n      if (userData.appealDraws) appealDraws = userData.appealDraws || []\n      if (userData.appealCreatedAt)\n        appealCreatedAt = userData.appealCreatedAt || []\n      if (userData.appealDeadlines)\n        appealDeadlines = userData.appealDeadlines || []\n      if (userData.appealRuledAt) appealRuledAt = userData.appealRuledAt || []\n      if (userData.netPNK) netPNK = userData.netPNK\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      // Fetching a dispute will fail if it hasn't been added to the store yet. This is ok, we can just not return store data\n    }\n\n    // Build juror info and ruling arrays, indexed by appeal number\n    const lastSession = dispute.firstSession + dispute.numberOfAppeals\n    const appealJuror = []\n    const appealRulings = []\n    for (let appeal = 0; appeal <= dispute.numberOfAppeals; appeal++) {\n      const isLastAppeal = dispute.firstSession + appeal === lastSession\n\n      // Get appeal data\n      const draws = appealDraws[appeal] || []\n      let canRule = false\n      let canRepartition = false\n      let canExecute = false\n      let ruling\n      const rulingPromises = [\n        this._ArbitratorInstance.currentRulingForDispute(disputeId, appeal)\n      ]\n\n      // Extra info for the last appeal\n      if (isLastAppeal) {\n        if (draws.length > 0)\n          rulingPromises.push(\n            this._ArbitratorInstance.canRuleDispute(disputeId, draws, account)\n          )\n\n        if (session && period)\n          canRepartition =\n            lastSession <= session && // Not appealed to the next session\n            period === arbitratorConstants.PERIOD.EXECUTE && // Executable period\n            dispute.state === disputeConstants.STATE.OPEN // Open dispute\n        canExecute = dispute.state === disputeConstants.STATE.EXECUTABLE // Executable state\n      }\n\n      // Wait for parallel requests to complete\n      ;[ruling, canRule] = await Promise.all(rulingPromises)\n\n      appealJuror[appeal] = {\n        createdAt: appealCreatedAt[appeal],\n        fee: dispute.arbitrationFeePerJuror * draws.length,\n        draws,\n        canRule\n      }\n      appealRulings[appeal] = {\n        voteCounter: dispute.voteCounters[appeal],\n        deadline: appealDeadlines[appeal],\n        ruledAt: appealRuledAt[appeal],\n        ruling,\n        canRepartition,\n        canExecute\n      }\n    }\n\n    return {\n      // Arbitrable Contract Data\n      arbitrableContractAddress,\n      arbitrableContractStatus: arbitrableContractData.status,\n      arbitratorAddress,\n      partyA: arbitrableContractData.partyA,\n      partyB: arbitrableContractData.partyB,\n\n      // Dispute Data\n      disputeId,\n      firstSession: dispute.firstSession,\n      lastSession,\n      numberOfAppeals: dispute.numberOfAppeals,\n      disputeState: dispute.state,\n      disputeStatus: dispute.status,\n      appealJuror,\n      appealRulings,\n\n      // Store Data\n      description: contractStoreData\n        ? contractStoreData.description\n        : undefined,\n      email: contractStoreData ? contractStoreData.email : undefined,\n      evidence,\n      netPNK,\n\n      // Deprecated Data // TODO: Remove\n      appealCreatedAt,\n      appealDeadlines,\n      appealRuledAt\n    }\n  }\n}\n\nexport default Disputes\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/Disputes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 184,
    "kind": "class",
    "name": "Disputes",
    "memberof": "src/resources/Disputes.js",
    "static": true,
    "longname": "src/resources/Disputes.js~Disputes",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/resources/Disputes.js",
    "importStyle": "Disputes",
    "description": "Disputes API. Provides cross arbitrator and arbitrable contracts functionality.\nRequires Store Provider to be set.",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 185,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/resources/Disputes.js~Disputes",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true
  },
  {
    "__docId__": 186,
    "kind": "member",
    "name": "_ArbitratorInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_ArbitratorInstance",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "_ArbitrableInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_ArbitrableInstance",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "_StoreProviderInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_StoreProviderInstance",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "setArbitratorInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#setArbitratorInstance",
    "access": "public",
    "description": "Set arbitrator instance.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorInstance",
        "description": "instance of an arbitrator contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "setArbitrableInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#setArbitrableInstance",
    "access": "public",
    "description": "Set arbitrable instance.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableInstance",
        "description": "instance of an arbitrable contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "member",
    "name": "registerStoreUpdateEventListeners",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#registerStoreUpdateEventListeners",
    "access": "public",
    "description": "Method to register all dispute handlers to an EventListener.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "eventListener",
        "description": "The EventListener instance. See utils/EventListener.js."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "_storeNewDisputeHandler",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_storeNewDisputeHandler",
    "access": "private",
    "description": "Event listener handler that stores dispute in store upon creation",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Account of user to update store data for"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "_storeTokensMovedForJuror",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_storeTokensMovedForJuror",
    "access": "private",
    "description": "Event listener handler that add or substract the stored Net PNK won/lost for a juror.",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "_storeDisputeRuledAtTimestamp",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_storeDisputeRuledAtTimestamp",
    "access": "private",
    "description": "Event listener handler that updates ruled at timestamp",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The users eth account."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "_storeAppealDeadline",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_storeAppealDeadline",
    "access": "private",
    "description": "Event listener handler that sets the deadline for an appeal",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "_",
        "description": "The event log. Unused in function."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The users eth account."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "getDisputeFromStore",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#getDisputeFromStore",
    "access": "public",
    "description": "Fetch the shared dispute data from the store.",
    "lineNumber": 256,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} The dispute data in the store."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "The index of the dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The dispute data in the store."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "getDataForDispute",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#getDataForDispute",
    "access": "public",
    "description": "Get data for a dispute. This method provides data from the store as well as both\narbitrator and arbitrable contracts. Used to get all relevant data on a dispute.",
    "lineNumber": 269,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Data object for the dispute that uses data from the contract and the store."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "The dispute's ID."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The juror's address."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Data object for the dispute that uses data from the contract and the store."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "file",
    "name": "src/resources/Notifications.js",
    "content": "import _ from 'lodash'\n\nimport * as arbitratorConstants from '../constants/arbitrator'\nimport * as notificationConstants from '../constants/notification'\nimport * as disputeConstants from '../constants/dispute'\nimport { MISSING_STORE_PROVIDER } from '../constants/error'\nimport isRequired from '../utils/isRequired'\n\n/**\n * Notifications API. Use this object to fetch notifications from the store, register\n * event log handlers to update store and send push notifications.\n */\nclass Notifications {\n  constructor(\n    arbitratorInstance = isRequired('arbitratorInstance'),\n    arbitrableInstance = isRequired('arbitrableInstance'),\n    storeProviderInstance\n  ) {\n    this._ArbitratorInstance = arbitratorInstance\n    this._ArbitrableInstance = arbitrableInstance\n    this._StoreProviderInstance = storeProviderInstance\n  }\n  /**\n   * Set arbitrator instance.\n   * @param {object} arbitratorInstance - instance of an arbitrator contract.\n   */\n  setArbitratorInstance = arbitratorInstance => {\n    this._ArbitratorInstance = arbitratorInstance\n  }\n  /**\n   * Set arbitrable instance.\n   * @param {object} arbitrableInstance - instance of an arbitrable contract.\n   */\n  setArbitrableInstance = arbitrableInstance => {\n    this._ArbitrableInstance = arbitrableInstance\n  }\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  // **************************** //\n  // *         Public           * //\n  // **************************** //\n\n  /**\n   * Register event handlers for the arbitrator instance.\n   * @param {string} account - Filter notifications for account.\n   * @param {object} eventListener - Event Listener that will fetch logs and call callbacks\n   * @param {function} callback - If we want notifications to be \"pushed\" provide a callback function to call when a new notification is created.\n   */\n  registerArbitratorNotifications = (\n    account = isRequired('account'),\n    eventListener = isRequired('eventListener'),\n    callback\n  ) => {\n    const eventHandlerMap = {\n      DisputeCreation: this._disputeCreationHandler,\n      AppealPossible: this._appealPossibleHandler,\n      AppealDecision: this._appealingDecisionHandler,\n      TokenShift: this._tokenShiftHandler,\n      ArbitrationReward: this._arbitrationRewardHandler,\n      NewPeriod: this._newPeriodHandler\n    }\n\n    for (let event in eventHandlerMap) {\n      if (eventHandlerMap.hasOwnProperty(event)) {\n        eventListener.addEventHandler(\n          this._ArbitratorInstance,\n          event,\n          this._createHandler(eventHandlerMap[event], account, callback)\n        )\n      }\n    }\n  }\n\n  /**\n   * Get stateful notifications. Stateful notifications change based on the state of the arbitrator contract.\n   * @param {string} account - Filter notifications for account.\n   * @param {function} isJuror - If the account is a juror.\n   * @returns {object[]} - Array of stateful notification objects.\n   */\n  getStatefulNotifications = async (account, isJuror = true) => {\n    const notifications = []\n    const [contracts, disputes] = await Promise.all([\n      this._getContracts(account),\n      this._getDisputes(account, isJuror)\n    ])\n    const currentPeriod = await this._ArbitratorInstance.getPeriod()\n    const currentSession = await this._ArbitratorInstance.getSession()\n    if (isJuror) {\n      /* Juror notifications:\n      * - Activate tokens\n      * - Need to vote\n      * - Ready to repartition (shared)\n      * - Ready to execute (shared)\n      */\n      if (currentPeriod === arbitratorConstants.PERIOD.ACTIVATION) {\n        // FIXME use estimateGas\n        const contractInstance = await this._ArbitratorInstance.loadContract()\n        const lastActivatedSession = (await contractInstance.jurors(\n          account\n        ))[2].toNumber()\n        if (lastActivatedSession < currentSession) {\n          notifications.push(\n            this._createNotification(\n              notificationConstants.TYPE.CAN_ACTIVATE,\n              'Ready to activate tokens',\n              {}\n            )\n          )\n        }\n      } else if (currentPeriod === arbitratorConstants.PERIOD.VOTE) {\n        for (let dispute of disputes) {\n          const draws = dispute.appealDraws[dispute.appealDraws.length - 1]\n          if (draws) {\n            const canVote = await this._ArbitratorInstance.canRuleDispute(\n              dispute.disputeId,\n              draws,\n              account\n            )\n            if (canVote) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_VOTE,\n                  'Need to vote on dispute',\n                  {\n                    disputeId: dispute.disputeId,\n                    arbitratorAddress: dispute.arbitratorAddress\n                  }\n                )\n              )\n            }\n          }\n        }\n      }\n    } else {\n      /* Counterparty notifications:\n      * - Need to pay fee\n      * - Ready to repartition (shared)\n      * - Ready to execute (shared)\n      */\n      await Promise.all(\n        contracts.map(async contract => {\n          // load arbitrable contract\n          await this._ArbitrableInstance.setContractInstance(contract.address)\n          const contractData = await this._ArbitrableInstance.getData(\n            contract.partyA\n          )\n          const arbitrationCost = await this._ArbitratorInstance.getArbitrationCost(\n            contractData.arbitratorExtraData\n          )\n          if (contractData.partyA === account) {\n            if (contractData.partyAFee < arbitrationCost) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_PAY_FEE,\n                  'Arbitration fee required',\n                  {\n                    arbitratorAddress: contractData.arbitrator,\n                    arbitrableContractAddress: contract.address,\n                    feeToPay: arbitrationCost - contractData.partyAFee\n                  }\n                )\n              )\n            }\n          } else if (contractData.partyB === account) {\n            if (contractData.partyBFee < arbitrationCost) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_PAY_FEE,\n                  'Arbitration fee required',\n                  {\n                    arbitratorAddress: contractData.arbitrator,\n                    arbitrableContractAddress: contract.address,\n                    feeToPay: arbitrationCost - contractData.partyBFee\n                  }\n                )\n              )\n            }\n          }\n        })\n      )\n    }\n\n    // Repartition and execute\n    if (currentPeriod === arbitratorConstants.PERIOD.EXECUTE) {\n      await Promise.all(\n        disputes.map(async dispute => {\n          const disputeData = await this._ArbitratorInstance.getDispute(\n            dispute.disputeId\n          )\n          if (\n            disputeData.firstSession + disputeData.numberOfAppeals ===\n            currentSession\n          ) {\n            if (disputeData.state <= disputeConstants.STATE.RESOLVING) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_REPARTITION,\n                  'Ready to repartition dispute',\n                  {\n                    disputeId: dispute.disputeId,\n                    arbitratorAddress: dispute.arbitratorAddress\n                  }\n                )\n              )\n            } else if (\n              disputeData.state === disputeConstants.STATE.EXECUTABLE\n            ) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_EXECUTE,\n                  'Ready to execute dispute',\n                  {\n                    disputeId: dispute.disputeId,\n                    arbitratorAddress: dispute.arbitratorAddress\n                  }\n                )\n              )\n            }\n          }\n        })\n      )\n    }\n    return notifications\n  }\n\n  /**\n   * Fetch all unread notifications from store.\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Array of notification objects.\n   */\n  getUnreadStoredNotifications = async account => {\n    this._requireStoreProvider()\n    const profile = await this._StoreProviderInstance.setUpUserProfile(account)\n    const currentArbitrator = this._ArbitratorInstance.getContractAddress()\n    // return notifications that are for current arbitrator and are unread\n    return _.filter(\n      profile.notifications,\n      notification =>\n        notification.data.arbitratorAddress === currentArbitrator &&\n        !notification.read\n    )\n  }\n\n  /**\n   * Mark stored notification as read.\n   * @param {string} account address of user\n   * @param {string} txHash hash of transaction that produced event\n   * @param {number} logIndex index of the log. used to differentiate logs if multiple logs per tx\n   * @returns {promise} promise that can be waited on for syncronousity\n   */\n  markStoredNotificationAsRead = async (account, txHash, logIndex) => {\n    this._requireStoreProvider()\n    const result = await this._StoreProviderInstance.markNotificationAsRead(\n      account,\n      txHash,\n      logIndex,\n      true\n    )\n    return result\n  }\n\n  /**\n   * Fetch all user notifications from store.\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Array of notification objects.\n   */\n  getStoredNotifications = async account => {\n    this._requireStoreProvider()\n\n    return (await this._StoreProviderInstance.getUserProfile(account))\n      .notifications\n  }\n\n  // **************************** //\n  // *        Handlers          * //\n  // **************************** //\n\n  /**\n   * Checks for appeal possible notifications during APPEAL period.\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _newPeriodHandler = async (event, account, callback) => {\n    const newPeriod = event.args._period.toNumber()\n\n    // send appeal possible notifications\n    if (newPeriod === arbitratorConstants.PERIOD.APPEAL) {\n      const disputes = await this._getDisputes(account) // get users disputes\n      const openDisputes = await this._ArbitratorInstance.getOpenDisputesForSession() // get all disputes for session\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n      await Promise.all(\n        openDisputes.map(async openDispute => {\n          if (\n            _.findIndex(\n              disputes,\n              dispute =>\n                dispute.disputeId === openDispute.disputeId &&\n                dispute.arbitratorAddress === arbitratorAddress\n            ) >= 0\n          ) {\n            const ruling = await this._ArbitratorInstance.currentRulingForDispute(\n              openDispute.disputeId,\n              openDispute.numberOfAppeals\n            )\n\n            const notification = await this._newNotification(\n              account,\n              event.transactionHash,\n              openDispute.disputeId, // use disputeId instead of logIndex since it doens't have its own event\n              notificationConstants.TYPE.APPEAL_POSSIBLE,\n              'A ruling has been made. Appeal is possible',\n              {\n                disputeId: openDispute.disputeId,\n                arbitratorAddress,\n                ruling\n              }\n            )\n\n            await this._sendPushNotification(callback, notification)\n          }\n        })\n      )\n    }\n  }\n\n  /**\n   * Handler for DisputeCreation event\n   * sends notification to partyA and partyB when dispute is created\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _disputeCreationHandler = async (event, account, callback) => {\n    const disputeId = event.args._disputeID.toNumber()\n    const txHash = event.transactionHash\n    // load arbitrable contract\n    await this._ArbitrableInstance.setContractInstance(event.args._arbitrable)\n\n    const arbitrableData = this._ArbitrableInstance.getData()\n\n    if (\n      arbitrableData.partyA === account ||\n      arbitrableData.partyB === account\n    ) {\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n      const notification = await this._newNotification(\n        account,\n        txHash,\n        event.logIndex,\n        notificationConstants.TYPE.DISPUTE_CREATED,\n        'New Dispute Created',\n        {\n          disputeId: disputeId,\n          arbitratorAddress: arbitratorAddress\n        }\n      )\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * handler for AppealPossible event\n   * sends notification informing accounts that a ruling has been made and an appeal possible\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _appealPossibleHandler = async (event, account, callback) => {\n    const disputes = await this._getDisputes(account)\n    const disputeId = event.args._disputeID.toNumber()\n    const ruling = await this._ArbitratorInstance.currentRulingForDispute(\n      disputeId\n    )\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n    if (\n      _.findIndex(\n        disputes,\n        dispute =>\n          dispute.disputeId === disputeId &&\n          dispute.arbitratorAddress === arbitratorAddress\n      ) >= 0\n    ) {\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.logIndex,\n        notificationConstants.TYPE.APPEAL_POSSIBLE,\n        'A ruling has been made. Appeal is possible',\n        {\n          disputeId,\n          arbitratorAddress,\n          ruling\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * Handler for AppealDecision event\n   * sends notification informing subscribers that a ruling has been appealed\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _appealingDecisionHandler = async (event, account, callback) => {\n    const disputes = await this._getDisputes(account)\n    const disputeId = event.args._disputeID.toNumber()\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n    if (\n      _.findIndex(\n        disputes,\n        dispute =>\n          dispute.disputeId === disputeId &&\n          dispute.arbitratorAddress === arbitratorAddress\n      ) >= 0\n    ) {\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.logIndex,\n        notificationConstants.TYPE.RULING_APPEALED,\n        'A ruling been appealed',\n        {\n          disputeId,\n          arbitratorAddress\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * Handler for TokenShift event.\n   * NOTE: you will get a notification for each vote. So a juror that has 3 votes will receive 3 notifications\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _tokenShiftHandler = async (event, account, callback) => {\n    // address indexed _account, uint _disputeID, int _amount\n    const disputeId = event.args._disputeID.toNumber()\n    const address = event.args._account\n    const amount = event.args._amount.toNumber()\n\n    if (account === address) {\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.logIndex,\n        notificationConstants.TYPE.TOKEN_SHIFT,\n        'Tokens have been redistributed',\n        {\n          disputeId,\n          arbitratorAddress,\n          account: address,\n          amount\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * Handler for arbitration reward event.\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _arbitrationRewardHandler = async (event, account, callback) => {\n    // address indexed _account, uint _disputeID, int _amount\n    const disputeId = event.args._disputeID.toNumber()\n    const address = event.args._account\n    const amount = event.args._amount.toNumber()\n\n    if (account === address) {\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.logIndex,\n        notificationConstants.TYPE.ARBITRATION_REWARD,\n        'Juror awarded arbitration fee',\n        {\n          disputeId,\n          arbitratorAddress,\n          account: address,\n          amount\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  // **************************** //\n  // *        Helpers           * //\n  // **************************** //\n  /**\n   * Helper method to create handler with correct params\n   * @param {function} handler - The handler.\n   * @param {string} account - The account.\n   * @param {function} callback - The callback.\n   * @returns {object} - The created handler.\n   */\n  _createHandler = (handler, account, callback) => args =>\n    handler(args, account, callback)\n\n  /**\n   * Sends a push notification.\n   * @param {function} callback - The callback.\n   * @param {object} notification - The notification.\n   */\n  _sendPushNotification = async (callback, notification) => {\n    if (callback && notification) {\n      callback(notification)\n    }\n  }\n\n  /**\n   * Creates a notification object.\n   * @param {number} notificationType - The notificationType.\n   * @param {string} message - The message.\n   * @param {object} data - The data.\n   * @returns {function} - The notification object.\n   */\n  _createNotification = (notificationType, message, data) => ({\n    notificationType,\n    message,\n    data\n  })\n\n  /**\n   * Creates a new notification object in the store.\n   * @param {string} account - The account.\n   * @param {string} txHash - The txHash.\n   * @param {number} logIndex - The logIndex.\n   * @param {number} notificationType - The notificationType.\n   * @param {string} message - The message.\n   * @param {object} data - The data.\n   * @param {bool} read - Wether the notification has been read or not.\n   * @returns {function} - The notification object.\n   */\n  _newNotification = async (\n    account,\n    txHash,\n    logIndex,\n    notificationType,\n    message = '',\n    data = {},\n    read = false\n  ) => {\n    if (this._StoreProviderInstance) {\n      const response = await this._StoreProviderInstance.newNotification(\n        account,\n        txHash,\n        logIndex,\n        notificationType,\n        message,\n        data,\n        read\n      )\n\n      if (response.status === 201) {\n        const notification = response.body.notifications.filter(\n          notification =>\n            notification.txHash === txHash && notification.logIndex === logIndex\n        )\n        return notification[0]\n      }\n    } else {\n      // If we have no store provider simply return object of params for a push notification\n      return {\n        txHash,\n        logIndex,\n        notificationType,\n        message,\n        data,\n        read\n      }\n    }\n  }\n\n  /**\n   * Get contracts from store if set or return empty array. Used for notifications\n   * @param {string} account - Filter notifications for account.\n   * @returns {object[]} - Array of dispute objects\n   */\n  _getContracts = async account => {\n    let contracts = []\n\n    // If we have store provider fetch contracts and disputes from the store.\n    if (this._StoreProviderInstance) {\n      const userProfile = await this._StoreProviderInstance.setUpUserProfile(\n        account\n      )\n\n      contracts = userProfile.contracts\n    }\n\n    return contracts\n  }\n\n  /**\n   * Get disputes either from store or from arbitrator if Store Provider is not set. Used for notifications\n   * @param {string} account - Filter notifications for account.\n   * @param {function} isJuror - If the account is a juror.\n   * @returns {object[]} - Array of dispute objects\n   */\n  _getDisputes = async (account, isJuror = true) => {\n    let disputes = []\n\n    // If we have store provider fetch contracts and disputes from the store.\n    if (this._StoreProviderInstance) {\n      disputes = await this._StoreProviderInstance.getDisputes(account)\n    } else if (isJuror) {\n      // We have no way to get contracts. Get disputes from current session\n      // TODO make a function to get open disputes for parites\n      disputes = await this._ArbitratorInstance.getDisputesForJuror(account)\n    }\n\n    return disputes\n  }\n\n  _requireStoreProvider = () => {\n    if (!this._StoreProviderInstance) throw new Error(MISSING_STORE_PROVIDER)\n  }\n}\n\nexport default Notifications\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/Notifications.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 203,
    "kind": "class",
    "name": "Notifications",
    "memberof": "src/resources/Notifications.js",
    "static": true,
    "longname": "src/resources/Notifications.js~Notifications",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/resources/Notifications.js",
    "importStyle": "Notifications",
    "description": "Notifications API. Use this object to fetch notifications from the store, register\nevent log handlers to update store and send push notifications.",
    "lineNumber": 13,
    "interface": false
  },
  {
    "__docId__": 204,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/resources/Notifications.js~Notifications",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "_ArbitratorInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_ArbitratorInstance",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "member",
    "name": "_ArbitrableInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_ArbitrableInstance",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "member",
    "name": "_StoreProviderInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_StoreProviderInstance",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "member",
    "name": "setArbitratorInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#setArbitratorInstance",
    "access": "public",
    "description": "Set arbitrator instance.",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorInstance",
        "description": "instance of an arbitrator contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "setArbitrableInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#setArbitrableInstance",
    "access": "public",
    "description": "Set arbitrable instance.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableInstance",
        "description": "instance of an arbitrable contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "registerArbitratorNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#registerArbitratorNotifications",
    "access": "public",
    "description": "Register event handlers for the arbitrator instance.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "eventListener",
        "description": "Event Listener that will fetch logs and call callbacks"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "If we want notifications to be \"pushed\" provide a callback function to call when a new notification is created."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "getStatefulNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#getStatefulNotifications",
    "access": "public",
    "description": "Get stateful notifications. Stateful notifications change based on the state of the arbitrator contract.",
    "lineNumber": 86,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of stateful notification objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "isJuror",
        "description": "If the account is a juror."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of stateful notification objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "getUnreadStoredNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#getUnreadStoredNotifications",
    "access": "public",
    "description": "Fetch all unread notifications from store.",
    "lineNumber": 237,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of notification objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of notification objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "markStoredNotificationAsRead",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#markStoredNotificationAsRead",
    "access": "public",
    "description": "Mark stored notification as read.",
    "lineNumber": 257,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{promise} promise that can be waited on for syncronousity"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "hash of transaction that produced event"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "index of the log. used to differentiate logs if multiple logs per tx"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "promise"
      ],
      "spread": false,
      "description": "promise that can be waited on for syncronousity"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "getStoredNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#getStoredNotifications",
    "access": "public",
    "description": "Fetch all user notifications from store.",
    "lineNumber": 273,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of notification objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of notification objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "_newPeriodHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_newPeriodHandler",
    "access": "private",
    "description": "Checks for appeal possible notifications during APPEAL period.",
    "lineNumber": 290,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "_disputeCreationHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_disputeCreationHandler",
    "access": "private",
    "description": "Handler for DisputeCreation event\nsends notification to partyA and partyB when dispute is created",
    "lineNumber": 341,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "member",
    "name": "_appealPossibleHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_appealPossibleHandler",
    "access": "private",
    "description": "handler for AppealPossible event\nsends notification informing accounts that a ruling has been made and an appeal possible",
    "lineNumber": 376,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "member",
    "name": "_appealingDecisionHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_appealingDecisionHandler",
    "access": "private",
    "description": "Handler for AppealDecision event\nsends notification informing subscribers that a ruling has been appealed",
    "lineNumber": 416,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "member",
    "name": "_tokenShiftHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_tokenShiftHandler",
    "access": "private",
    "description": "Handler for TokenShift event.\nNOTE: you will get a notification for each vote. So a juror that has 3 votes will receive 3 notifications",
    "lineNumber": 452,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "member",
    "name": "_arbitrationRewardHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_arbitrationRewardHandler",
    "access": "private",
    "description": "Handler for arbitration reward event.",
    "lineNumber": 484,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "member",
    "name": "_createHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_createHandler",
    "access": "private",
    "description": "Helper method to create handler with correct params",
    "lineNumber": 520,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The created handler."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "The handler."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The created handler."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "member",
    "name": "_sendPushNotification",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_sendPushNotification",
    "access": "private",
    "description": "Sends a push notification.",
    "lineNumber": 528,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "notification",
        "description": "The notification."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "_createNotification",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_createNotification",
    "access": "private",
    "description": "Creates a notification object.",
    "lineNumber": 541,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function} - The notification object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "notificationType",
        "description": "The notificationType."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": "The notification object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "member",
    "name": "_newNotification",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_newNotification",
    "access": "private",
    "description": "Creates a new notification object in the store.",
    "lineNumber": 558,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function} - The notification object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "The txHash."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "The logIndex."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "notificationType",
        "description": "The notificationType."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data."
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "read",
        "description": "Wether the notification has been read or not."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": "The notification object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "member",
    "name": "_getContracts",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_getContracts",
    "access": "private",
    "description": "Get contracts from store if set or return empty array. Used for notifications",
    "lineNumber": 603,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of dispute objects"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of dispute objects"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "member",
    "name": "_getDisputes",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_getDisputes",
    "access": "private",
    "description": "Get disputes either from store or from arbitrator if Store Provider is not set. Used for notifications",
    "lineNumber": 624,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of dispute objects"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "isJuror",
        "description": "If the account is a juror."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of dispute objects"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "member",
    "name": "_requireStoreProvider",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_requireStoreProvider",
    "access": "private",
    "description": null,
    "lineNumber": 639,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "file",
    "name": "src/resources/index.js",
    "content": "import Disputes from './Disputes'\nimport Notifications from './Notifications'\nimport Auth from './Auth'\n\nexport { Disputes, Notifications, Auth }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 233,
    "kind": "file",
    "name": "src/utils/EventListener.js",
    "content": "import _ from 'lodash'\n\nimport PromiseQueue from '../utils/PromiseQueue'\nimport isRequired from '../utils/isRequired'\nimport * as errorConstants from '../constants/error'\n\n/**\n * EventListener is used to watch events on the blockchain for a set of contracts.\n * Handlers for specific events can be added. When an event log is found EventListener\n * will fire all handlers registered for the contract.\n */\nclass EventListener {\n  /**\n   * Listen for events in contract and handles callbacks with registered event handlers.\n   * @param {object[]} _contractImplementations - Contract Implementation instances to fetch event logs for.\n   */\n  constructor(_contractImplementations = []) {\n    this.contractInstances = []\n    // map address -> { event: [handlers], ... }\n    this.contractEventHandlerMap = {}\n    // map address -> watcher instance\n    this.watcherInstances = {}\n    // event handler queue\n    this.eventHandlerQueue = new PromiseQueue()\n    // initialize class variables for new contract instances\n    _contractImplementations.forEach(instance => {\n      this.addContractImplementation(instance)\n    })\n  }\n\n  /**\n   * Fetch all logs from contractInstance in a block range.\n   * @param {object} contractImplementationInstance - Contract Implementation instance.\n   * @param {number} firstBlock - Lower bound of search range.\n   * @param {number} lastBlock - Upper bound of search range.\n   * @returns {Promise} All events in block range.\n   */\n  static getAllEventLogs = async (\n    contractImplementationInstance = isRequired(\n      'contractImplementationInstance'\n    ),\n    firstBlock = 0,\n    lastBlock = 'latest'\n  ) =>\n    Promise.all(\n      (await contractImplementationInstance.loadContract())\n        .allEvents({\n          fromBlock: firstBlock,\n          toBlock: lastBlock\n        })\n        .get((error, result) => {\n          if (error)\n            throw new Error(errorConstants.ERROR_FETCHING_EVENTS(error))\n\n          return result\n        })\n    )\n\n  /**\n   * Fetch logs from contractInstance for a specific event in a block range.\n   * @param {object} contractImplementationInstance - contract Implementation instance.\n   * @param {string} eventName - Name of the event.\n   * @param {number} firstBlock - Lower bound of search range.\n   * @param {number} lastBlock - Upper bound of search range.\n   * @returns {Promise} All events in block range.\n   */\n  static getEventLogs = async (\n    contractImplementationInstance = isRequired(\n      'contractImplementationInstance'\n    ),\n    eventName = isRequired('eventName'),\n    firstBlock = 0,\n    lastBlock = 'latest'\n  ) =>\n    Promise.all(\n      (await contractImplementationInstance.loadContract())\n        [eventName]({\n          fromBlock: firstBlock,\n          toBlock: lastBlock\n        })\n        .get((error, result) => {\n          if (error)\n            throw new Error(errorConstants.ERROR_FETCHING_EVENTS(error))\n\n          if (eventName === result.event) return result\n        })\n    )\n\n  /**\n   * Add a contract instance to watch for new event logs.\n   * @param {object} contractImplementationInstance - Contract Implementation instance\n   */\n  addContractImplementation = contractImplementationInstance => {\n    this.contractInstances.push(contractImplementationInstance)\n    this.contractEventHandlerMap[\n      contractImplementationInstance.getContractAddress()\n    ] = {}\n  }\n\n  /**\n   * Remove contract instance being watched. Will also remove all handlers.\n   * @param {string} contractImplementationInstance - contract implementation instance\n   */\n  removeContractInstance = (\n    contractImplementationInstance = isRequired(\n      'contractImplementationInstance'\n    )\n  ) => {\n    const contractAddress = contractImplementationInstance.getContractAddress()\n    // remove instance from this.contractInstances\n    const removedInstance = _.remove(\n      this.contractInstances,\n      instance => instance.getContractAddress() === contractAddress\n    )\n    // if we didn't remove anything throw error\n    if (removedInstance.length === 0)\n      throw new Error(errorConstants.MISSING_CONTRACT_INSTANCE(contractAddress))\n    // stop watching on these instances\n    removedInstance.forEach(instance => this.stopWatchingForEvents(instance))\n\n    // remove handlers for contract instance\n    delete this.contractEventHandlerMap[contractAddress]\n  }\n\n  /**\n   * Add event handler that will be called when event log is found.\n   * @param {string} contractImplementationInstance - Contract implementation instance\n   * @param {string} eventName - Name of event.\n   * @param {function} handler - Function to be called when event is consumed.\n   */\n  addEventHandler = (\n    contractImplementationInstance = isRequired('contractAddress'),\n    eventName = isRequired('eventName'),\n    handler = isRequired('handler')\n  ) => {\n    const contractAddress = contractImplementationInstance.getContractAddress()\n    if (!this.contractEventHandlerMap[contractAddress][eventName])\n      this.contractEventHandlerMap[contractAddress][eventName] = []\n    this.contractEventHandlerMap[contractAddress][eventName].push(handler)\n  }\n\n  /**\n   * Watch for events on all contract instances. Call registered handlers when logs are found.\n   * @param {number} fromBlock - A block number can be passed to catch up on missed logs\n   * @returns {Promise} - Promise resolves when all watchers have been started\n   */\n  watchForEvents = async (fromBlock = 'latest') =>\n    Promise.all(\n      this.contractInstances.map(async contractImplementation => {\n        const instance = await contractImplementation.loadContract()\n        const newWatcherInstance = instance.allEvents({\n          fromBlock: fromBlock,\n          lastBlock: 'latest'\n        })\n\n        // NOTE: should we allow more than one listener per contract instance?\n        if (this.watcherInstances[instance.address])\n          this.watcherInstances[instance.address].stopWatching()\n\n        this.watcherInstances[instance.address] = newWatcherInstance\n        newWatcherInstance.watch((error, result) => {\n          if (!error) {\n            const handlers = this.contractEventHandlerMap[instance.address][\n              result.event\n            ]\n            if (handlers) {\n              handlers.forEach(handler => {\n                this._queueEvent(handler, result)\n              })\n            }\n          }\n        })\n      })\n    )\n\n  /**\n   * Stop listening on contract. If no contractAddress supplied it stops all listeners.\n   * @param {string} contractImplementationInstance - Address of the contract to stop watching\n   */\n  stopWatchingForEvents = contractImplementationInstance => {\n    if (contractImplementationInstance)\n      this.watcherInstances[\n        contractImplementationInstance.getContractAddress()\n      ].stopWatching()\n    else\n      this.contractInstances.forEach(instance => {\n        this.watcherInstances[instance.getContractAddress()].stopWatching()\n      })\n  }\n\n  /**\n   * Queues an event.\n   * @param {function} handler - The handler.\n   * @param {object} event - The event.\n   */\n  _queueEvent = async (handler, event) => {\n    const eventTask = async () => {\n      await handler(event)\n    }\n\n    this.eventHandlerQueue.push(eventTask)\n  }\n}\n\nexport default EventListener\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/EventListener.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 234,
    "kind": "class",
    "name": "EventListener",
    "memberof": "src/utils/EventListener.js",
    "static": true,
    "longname": "src/utils/EventListener.js~EventListener",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/EventListener.js",
    "importStyle": "EventListener",
    "description": "EventListener is used to watch events on the blockchain for a set of contracts.\nHandlers for specific events can be added. When an event log is found EventListener\nwill fire all handlers registered for the contract.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 235,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/EventListener.js~EventListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#constructor",
    "access": "public",
    "description": "Listen for events in contract and handles callbacks with registered event handlers.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "_contractImplementations",
        "description": "Contract Implementation instances to fetch event logs for."
      }
    ]
  },
  {
    "__docId__": 236,
    "kind": "member",
    "name": "contractInstances",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#contractInstances",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "member",
    "name": "contractEventHandlerMap",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#contractEventHandlerMap",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "member",
    "name": "watcherInstances",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#watcherInstances",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "member",
    "name": "eventHandlerQueue",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#eventHandlerQueue",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "member",
    "name": "getAllEventLogs",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": true,
    "longname": "src/utils/EventListener.js~EventListener.getAllEventLogs",
    "access": "public",
    "description": "Fetch all logs from contractInstance in a block range.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} All events in block range."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Contract Implementation instance."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "firstBlock",
        "description": "Lower bound of search range."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lastBlock",
        "description": "Upper bound of search range."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "All events in block range."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "member",
    "name": "getEventLogs",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": true,
    "longname": "src/utils/EventListener.js~EventListener.getEventLogs",
    "access": "public",
    "description": "Fetch logs from contractInstance for a specific event in a block range.",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} All events in block range."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "contract Implementation instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventName",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "firstBlock",
        "description": "Lower bound of search range."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lastBlock",
        "description": "Upper bound of search range."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "All events in block range."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "member",
    "name": "addContractImplementation",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#addContractImplementation",
    "access": "public",
    "description": "Add a contract instance to watch for new event logs.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Contract Implementation instance"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "member",
    "name": "removeContractInstance",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#removeContractInstance",
    "access": "public",
    "description": "Remove contract instance being watched. Will also remove all handlers.",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "contract implementation instance"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "addEventHandler",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#addEventHandler",
    "access": "public",
    "description": "Add event handler that will be called when event log is found.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Contract implementation instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventName",
        "description": "Name of event."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Function to be called when event is consumed."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "watchForEvents",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#watchForEvents",
    "access": "public",
    "description": "Watch for events on all contract instances. Call registered handlers when logs are found.",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Promise resolves when all watchers have been started"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "fromBlock",
        "description": "A block number can be passed to catch up on missed logs"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise resolves when all watchers have been started"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "member",
    "name": "stopWatchingForEvents",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#stopWatchingForEvents",
    "access": "public",
    "description": "Stop listening on contract. If no contractAddress supplied it stops all listeners.",
    "lineNumber": 180,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Address of the contract to stop watching"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "member",
    "name": "_queueEvent",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#_queueEvent",
    "access": "private",
    "description": "Queues an event.",
    "lineNumber": 196,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "The handler."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "file",
    "name": "src/utils/PromiseQueue.js",
    "content": "/**\n * Chain promises so that they are evaluated in order.\n * @returns {object} - The promise queue object.\n */\nconst PromiseQueue = () => {\n  let promise = Promise.resolve()\n\n  return {\n    push: fn => {\n      promise = promise.then(fn, fn)\n    },\n    fetch: fn => {\n      let returnResolver\n      let returnRejecter\n      const returnPromise = new Promise((resolve, reject) => {\n        returnResolver = resolve\n        returnRejecter = reject\n      })\n      promise = promise\n        .then(fn, fn)\n        .then(res => returnResolver(res), err => returnRejecter(err))\n\n      return returnPromise\n    }\n  }\n}\n\nexport default PromiseQueue\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/PromiseQueue.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 249,
    "kind": "function",
    "name": "PromiseQueue",
    "memberof": "src/utils/PromiseQueue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/PromiseQueue.js~PromiseQueue",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/PromiseQueue.js",
    "importStyle": "PromiseQueue",
    "description": "Chain promises so that they are evaluated in order.",
    "lineNumber": 5,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The promise queue object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The promise queue object."
    },
    "params": []
  },
  {
    "__docId__": 250,
    "kind": "file",
    "name": "src/utils/StoreProviderWrapper.js",
    "content": "import _ from 'lodash'\n\nimport * as errorConstants from '../constants/error'\n\nimport PromiseQueue from './PromiseQueue'\n\n/**\n * A wrapper for interacting with Kleros Store.\n */\nclass StoreProviderWrapper {\n  /**\n   * Create a new instance of StoreProviderWrapper.\n   * @param {string} storeProviderUri - The uri of kleros store.\n   * @param {string} authToken - Signed token cooresponding to user profile address.\n   */\n  constructor(storeProviderUri, authToken) {\n    this._storeUri = storeProviderUri\n    this._token = authToken\n    this._storeQueue = new PromiseQueue()\n  }\n\n  /**\n   * Helper method for sending an http request to kleros store.\n   * @param {string} verb - HTTP verb to be used in request. E.g. GET, POST, PUT.\n   * @param {string} uri - The uri to send the request to.\n   * @param {string} body - json string of the body.\n   * @returns {Promise} request promise that resolves to the HTTP response.\n   */\n  _makeRequest = (verb, uri, body = null) => {\n    if (verb !== 'GET' && !this._token) {\n      throw new Error(\n        'No auth token set. Cannot make writes to store. Please call setAuthToken or validateNewAuthToken.'\n      )\n    }\n\n    const httpRequest = new XMLHttpRequest()\n    return new Promise((resolve, reject) => {\n      try {\n        httpRequest.open(verb, uri, true)\n        if (body) {\n          httpRequest.setRequestHeader(\n            'Content-Type',\n            'application/json;charset=UTF-8'\n          )\n          httpRequest.setRequestHeader('Authorization', this._token)\n        }\n        httpRequest.onreadystatechange = () => {\n          if (httpRequest.readyState === 4) {\n            let body = null\n            try {\n              body = JSON.parse(httpRequest.responseText)\n              // eslint-disable-next-line no-unused-vars\n            } catch (err) {}\n            // auth token error\n            if (httpRequest.status === 401)\n              reject(errorConstants.INVALID_AUTH_TOKEN(body.error))\n\n            resolve({\n              body: body,\n              status: httpRequest.status\n            })\n          }\n        }\n        httpRequest.send(body)\n      } catch (err) {\n        reject(errorConstants.REQUEST_FAILED(err))\n      }\n    })\n  }\n\n  /**\n   * use the queue for write request. this allows a function to be passed so we can read immediately before we write\n   * @param {fn} getBodyFn async function to call before we write. Should to reads and return JSON to be used as body.\n   * @param {string} verb POST or PUT\n   * @param {string} uri uri to call\n   * @returns {promise} promise that returns result of request. wait on this if you need it to be syncronous\n   */\n  queueWriteRequest = (getBodyFn, verb, uri = null) =>\n    this._storeQueue.fetch(() =>\n      getBodyFn().then(result => this._makeRequest(verb, uri, result))\n    )\n\n  /**\n   * If we know we are waiting on some other write before we want to read we can add a read request to the end of the queue.\n   * @param {string} uri uri to hit\n   * @returns {Promise} promise of the result function\n   */\n  queueReadRequest = uri =>\n    this._storeQueue.fetch(() => this._makeRequest('GET', uri))\n\n  // **************************** //\n  // *          Auth            * //\n  // **************************** //\n\n  /**\n   * Set the auth token for write requests.\n   * @param {string} token - Hex string of the signed data token.\n   */\n  setAuthToken = token => {\n    this._token = token\n  }\n\n  /**\n   * Generate a new unsigned auth token.\n   * @param {string} userAddress - Address of the user profile.\n   * @returns {string} Hex encoded unsigned token.\n   */\n  newAuthToken = async userAddress => {\n    const newTokenResponse = await this._makeRequest(\n      'GET',\n      `${this._storeUri}/${userAddress}/authToken`\n    )\n\n    return newTokenResponse.body\n  }\n\n  /**\n   * Validate auth token\n   * @param {string} userAddress - Address of user profile.\n   * @param {string} token - <optional> token to use. Sets token.\n   * @returns {bool} - True if token is valid.\n   */\n  isTokenValid = async (userAddress, token) => {\n    if (token) this.setAuthToken(token)\n\n    try {\n      const response = await this._makeRequest(\n        'POST',\n        `${this._storeUri}/${userAddress}/authToken/verify`,\n        JSON.stringify({})\n      )\n\n      return response.status === 201\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      return false\n    }\n  }\n\n  // **************************** //\n  // *          Read            * //\n  // **************************** //\n\n  /**\n   * Fetch stored user profile.\n   * @param {string} userAddress - Address of user.\n   * @returns {object} - a response object.\n   */\n  getUserProfile = async userAddress => {\n    const httpResponse = await this._makeRequest(\n      'GET',\n      `${this._storeUri}/${userAddress}`\n    )\n\n    return httpResponse.body\n  }\n\n  /**\n   * Fetch stored data on a contract for a user.\n   * @param {string} userAddress - Address of the user.\n   * @param {string} addressContract - The address of the contract.\n   * @returns {object} - Contact data.\n   */\n  getContractByAddress = async (userAddress, addressContract) => {\n    const userProfile = await this.getUserProfile(userAddress)\n    if (!userProfile)\n      throw new Error(errorConstants.PROFILE_NOT_FOUND(userAddress))\n\n    let contract = _.filter(\n      userProfile.contracts,\n      contract => contract.address === addressContract\n    )\n\n    return contract[0]\n  }\n\n  /**\n   * Get all stored data for a dispute. Must exist in User Profile.\n   * @param {string} userAddress - Address of user.\n   * @param {string} arbitratorAddress - Address of arbitrator contract.\n   * @param {number} disputeId - Index of the dispute.\n   * @returns {object} - a response object.\n   */\n  getDisputeDataForUser = async (userAddress, arbitratorAddress, disputeId) => {\n    const userProfile = await this.getUserProfile(userAddress)\n    if (!userProfile)\n      throw new Error(errorConstants.PROFILE_NOT_FOUND(userAddress))\n\n    return _.filter(\n      userProfile.disputes,\n      o =>\n        o.arbitratorAddress === arbitratorAddress && o.disputeId === disputeId\n    )[0]\n  }\n\n  /**\n   * Fetch stored disputes for a user.\n   * @param {string} userAddress - Address of user.\n   * @returns {object} - a response object.\n   */\n  getDisputes = async userAddress => {\n    const userProfile = await this.getUserProfile(userAddress)\n    if (!userProfile) return []\n\n    return userProfile.disputes\n  }\n\n  /**\n   * Fetch the last block seen for a user. This is commonly used with EventListerer.\n   * @param {string} userAddress - Address of user.\n   * @returns {number} The last block number.\n   */\n  getLastBlock = async userAddress => {\n    const userProfile = await this.setUpUserProfile(userAddress)\n\n    return userProfile.lastBlock || 0\n  }\n\n  // **************************** //\n  // *          Write           * //\n  // **************************** //\n\n  /**\n   * Update user profile. WARNING: This should only be used for session and lastBlock.\n   * Overwriting arrays of unstructured data can lead to data loss.\n   * @param {string} userAddress - users userAddress\n   * @param {object} params - object containing kwargs to update\n   * @returns {promise} - resulting profile\n   */\n  updateUserProfile = (userAddress, params = {}) => {\n    const getBodyFn = async () => {\n      const currentProfile = (await this.getUserProfile(userAddress)) || {}\n      delete currentProfile._id\n      delete currentProfile.created_at\n\n      params.address = userAddress\n\n      return JSON.stringify({ ...currentProfile, ...params })\n    }\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}`\n    )\n  }\n\n  /**\n   * Set up a new user profile if one does not exist.\n   * @param {string} userAddress - user's address\n   * @returns {object} - users existing or created profile\n   */\n  setUpUserProfile = async userAddress => {\n    let userProfile = await this.getUserProfile(userAddress)\n    if (_.isNull(userProfile)) {\n      const response = await this.updateUserProfile(userAddress, {})\n      if (response.status !== 201)\n        throw new Error(errorConstants.REQUEST_FAILED(response.responseText))\n      userProfile = response.body\n    }\n\n    return userProfile\n  }\n\n  /**\n   * Update the stored data on a contract for a user.\n   * @param {string} userAddress - The user's address.\n   * @param {string} contractAddress - The address of the contract.\n   * @param {object} params - Params we want to update.\n   * @returns {Promise} - The resulting contract data.\n   */\n  updateContract = async (userAddress, contractAddress, params) => {\n    const getBodyFn = async () => {\n      let currentContractData = await this.getContractByAddress(\n        userAddress,\n        contractAddress\n      )\n      if (!currentContractData) currentContractData = {}\n      delete currentContractData._id\n\n      params.address = contractAddress\n\n      return JSON.stringify({ ...currentContractData, ...params })\n    }\n\n    const httpResponse = await this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/contracts/${contractAddress}`\n    )\n\n    if (httpResponse.status !== 201) {\n      throw new Error(errorConstants.REQUEST_FAILED(httpResponse.error))\n    }\n\n    return _.filter(\n      httpResponse.body[0].contracts,\n      contract => contract.address === contractAddress\n    )[0]\n  }\n\n  /**\n   * Adds new evidence to the store for a users contract. NOTE this will only update the\n   * stored evidence for the specified user, not all parties of the dispute.\n   * @param {string} contractAddress - Address of the contract\n   * @param {string} userAddress - Address of the user.\n   * @param {string} name - Name of evidence.\n   * @param {string} description - Description of evidence.\n   * @param {string} url - A link to the evidence.\n   * @returns {Promise} - The resulting evidence data.\n   */\n  addEvidenceContract = (\n    contractAddress,\n    userAddress,\n    name,\n    description,\n    url\n  ) => {\n    // get timestamp for submission\n    const submittedAt = new Date().getTime()\n\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            name,\n            description,\n            url,\n            submittedAt\n          })\n        )\n      )\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/contracts/${contractAddress}/evidence`\n    )\n  }\n\n  /**\n   * Update stored dispute data for a user.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} arbitratorAddress - The address of the arbitrator contract.\n   * @param {number} disputeId - The index of the dispute.\n   * @param {object} params - The dispute data we are updating.\n   * @returns {Promise} The resulting dispute data.\n   */\n  updateDisputeProfile = (\n    userAddress,\n    arbitratorAddress,\n    disputeId,\n    params\n  ) => {\n    const getBodyFn = async () => {\n      const userProfile = await this.setUpUserProfile(userAddress)\n\n      const currentDisputeProfile =\n        _.filter(\n          userProfile.disputes,\n          dispute =>\n            dispute.arbitratorAddress === arbitratorAddress &&\n            dispute.disputeId === disputeId\n        )[0] || {}\n\n      delete currentDisputeProfile._id\n      // set these so if it is a new dispute they are included\n      params.disputeId = disputeId\n      params.arbitratorAddress = arbitratorAddress\n\n      return JSON.stringify({ ...currentDisputeProfile, ...params })\n    }\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${\n        this._storeUri\n      }/${userAddress}/arbitrators/${arbitratorAddress}/disputes/${disputeId}`\n    )\n  }\n\n  /**\n   * Create a new notification in the store.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} txHash - The transaction hash which produced this event log. Used as an identifier.\n   * @param {number} logIndex - The index of the log in the transaction. Used as an identifier.\n   * @param {number} notificationType - The type of the notification. See constants/notification.\n   * @param {string} message - The message to be stored with the notification.\n   * @param {object} data - Any extra data stored with the notification.\n   * @param {boolean} read - If the notification has been read or not.\n   * @returns {Promise} - The resulting notification.\n   */\n  newNotification = async (\n    userAddress,\n    txHash,\n    logIndex,\n    notificationType,\n    message = '',\n    data = {},\n    read = false\n  ) => {\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            notificationType,\n            logIndex,\n            read,\n            message,\n            data\n          })\n        )\n      )\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/notifications/${txHash}`\n    )\n  }\n\n  /**\n   * Create a new notification in the store.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} txHash - The transaction hash which produced this event log. Used as an identifier.\n   * @param {number} logIndex - The index of the log in the transaction. Used as an identifier.\n   * @param {boolean} isRead - If the notification has been read or not.\n   * @returns {Promise} - The resulting notification.\n   */\n  markNotificationAsRead = async (\n    userAddress,\n    txHash,\n    logIndex,\n    isRead = true\n  ) => {\n    const getBodyFn = async () => {\n      const userProfile = await this.setUpUserProfile(userAddress)\n\n      const notificationIndex = await _.findIndex(\n        userProfile.notifications,\n        notification =>\n          notification.txHash === txHash && notification.logIndex === logIndex\n      )\n\n      if (_.isNull(notificationIndex))\n        throw new Error(errorConstants.NOTIFICATION_NOT_FOUND(txHash))\n\n      userProfile.notifications[notificationIndex].read = isRead\n      delete userProfile._id\n      delete userProfile.created_at\n      return JSON.stringify(userProfile)\n    }\n\n    const result = await this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}`\n    )\n\n    return result.body.notifications\n  }\n}\n\nexport default StoreProviderWrapper\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/StoreProviderWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 251,
    "kind": "class",
    "name": "StoreProviderWrapper",
    "memberof": "src/utils/StoreProviderWrapper.js",
    "static": true,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/StoreProviderWrapper.js",
    "importStyle": "StoreProviderWrapper",
    "description": "A wrapper for interacting with Kleros Store.",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 252,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#constructor",
    "access": "public",
    "description": "Create a new instance of StoreProviderWrapper.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderUri",
        "description": "The uri of kleros store."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "authToken",
        "description": "Signed token cooresponding to user profile address."
      }
    ]
  },
  {
    "__docId__": 253,
    "kind": "member",
    "name": "_storeUri",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#_storeUri",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 254,
    "kind": "member",
    "name": "_token",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#_token",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "_storeQueue",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#_storeQueue",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "member",
    "name": "_makeRequest",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#_makeRequest",
    "access": "private",
    "description": "Helper method for sending an http request to kleros store.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} request promise that resolves to the HTTP response."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verb",
        "description": "HTTP verb to be used in request. E.g. GET, POST, PUT."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uri",
        "description": "The uri to send the request to."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "body",
        "description": "json string of the body."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "request promise that resolves to the HTTP response."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "member",
    "name": "queueWriteRequest",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#queueWriteRequest",
    "access": "public",
    "description": "use the queue for write request. this allows a function to be passed so we can read immediately before we write",
    "lineNumber": 78,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{promise} promise that returns result of request. wait on this if you need it to be syncronous"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "fn"
        ],
        "spread": false,
        "optional": false,
        "name": "getBodyFn",
        "description": "async function to call before we write. Should to reads and return JSON to be used as body."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verb",
        "description": "POST or PUT"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uri",
        "description": "uri to call"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "promise"
      ],
      "spread": false,
      "description": "promise that returns result of request. wait on this if you need it to be syncronous"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "member",
    "name": "queueReadRequest",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#queueReadRequest",
    "access": "public",
    "description": "If we know we are waiting on some other write before we want to read we can add a read request to the end of the queue.",
    "lineNumber": 88,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} promise of the result function"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uri",
        "description": "uri to hit"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "promise of the result function"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "member",
    "name": "setAuthToken",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#setAuthToken",
    "access": "public",
    "description": "Set the auth token for write requests.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "token",
        "description": "Hex string of the signed data token."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "member",
    "name": "newAuthToken",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#newAuthToken",
    "access": "public",
    "description": "Generate a new unsigned auth token.",
    "lineNumber": 108,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} Hex encoded unsigned token."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of the user profile."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Hex encoded unsigned token."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "member",
    "name": "isTokenValid",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#isTokenValid",
    "access": "public",
    "description": "Validate auth token",
    "lineNumber": 123,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{bool} - True if token is valid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user profile."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "token",
        "description": "<optional> token to use. Sets token."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": "True if token is valid."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "member",
    "name": "getUserProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getUserProfile",
    "access": "public",
    "description": "Fetch stored user profile.",
    "lineNumber": 149,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - a response object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a response object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "member",
    "name": "getContractByAddress",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getContractByAddress",
    "access": "public",
    "description": "Fetch stored data on a contract for a user.",
    "lineNumber": 164,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Contact data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "addressContract",
        "description": "The address of the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Contact data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "member",
    "name": "getDisputeDataForUser",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getDisputeDataForUser",
    "access": "public",
    "description": "Get all stored data for a dispute. Must exist in User Profile.",
    "lineNumber": 184,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - a response object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "Address of arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "Index of the dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a response object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "member",
    "name": "getDisputes",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getDisputes",
    "access": "public",
    "description": "Fetch stored disputes for a user.",
    "lineNumber": 201,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - a response object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a response object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 267,
    "kind": "member",
    "name": "getLastBlock",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getLastBlock",
    "access": "public",
    "description": "Fetch the last block seen for a user. This is commonly used with EventListerer.",
    "lineNumber": 213,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The last block number."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The last block number."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 268,
    "kind": "member",
    "name": "updateUserProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#updateUserProfile",
    "access": "public",
    "description": "Update user profile. WARNING: This should only be used for session and lastBlock.\nOverwriting arrays of unstructured data can lead to data loss.",
    "lineNumber": 230,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{promise} - resulting profile"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "users userAddress"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "object containing kwargs to update"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "promise"
      ],
      "spread": false,
      "description": "resulting profile"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 269,
    "kind": "member",
    "name": "setUpUserProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#setUpUserProfile",
    "access": "public",
    "description": "Set up a new user profile if one does not exist.",
    "lineNumber": 253,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - users existing or created profile"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "user's address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "users existing or created profile"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "member",
    "name": "updateContract",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#updateContract",
    "access": "public",
    "description": "Update the stored data on a contract for a user.",
    "lineNumber": 272,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The resulting contract data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The user's address."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "The address of the contract."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Params we want to update."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting contract data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "member",
    "name": "addEvidenceContract",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#addEvidenceContract",
    "access": "public",
    "description": "Adds new evidence to the store for a users contract. NOTE this will only update the\nstored evidence for the specified user, not all parties of the dispute.",
    "lineNumber": 312,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The resulting evidence data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of the contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "Description of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to the evidence."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting evidence data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "member",
    "name": "updateDisputeProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#updateDisputeProfile",
    "access": "public",
    "description": "Update stored dispute data for a user.",
    "lineNumber": 349,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} The resulting dispute data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeId",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "The dispute data we are updating."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting dispute data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 273,
    "kind": "member",
    "name": "newNotification",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#newNotification",
    "access": "public",
    "description": "Create a new notification in the store.",
    "lineNumber": 394,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The resulting notification."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "The transaction hash which produced this event log. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "The index of the log in the transaction. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "notificationType",
        "description": "The type of the notification. See constants/notification."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message to be stored with the notification."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Any extra data stored with the notification."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "read",
        "description": "If the notification has been read or not."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting notification."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "markNotificationAsRead",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#markNotificationAsRead",
    "access": "public",
    "description": "Create a new notification in the store.",
    "lineNumber": 431,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The resulting notification."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "The transaction hash which produced this event log. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "The index of the log in the transaction. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isRead",
        "description": "If the notification has been read or not."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting notification."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "file",
    "name": "src/utils/Web3Wrapper.js",
    "content": "import _ from 'lodash'\nimport Web3 from 'web3'\n\nclass Web3Wrapper {\n  /**\n   * Constructor Web3 wrapper.\n   * @param {object} web3Provider - The web3 instance.\n   */\n  constructor(web3Provider) {\n    this._web3 = new Web3(web3Provider)\n  }\n\n  isAddress = address => this._web3.isAddress(address)\n\n  getAccount = index => this._web3.eth.accounts[index]\n\n  getProvider = () => this._web3.currentProvider\n\n  getCoinbase = () => this._web3.eth.coinbase\n\n  toWei = (amount, unit) => {\n    const newAmount = this._web3.toWei(amount, unit)\n    return newAmount.toNumber ? newAmount.toNumber() : Number(newAmount)\n  }\n\n  fromWei = (amount, unit) => {\n    const newAmount = this._web3.fromWei(amount, unit)\n    return newAmount.toNumber ? newAmount.toNumber() : Number(newAmount)\n  }\n\n  toBigNumber = number => this._web3.toBigNumber(number)\n\n  blockNumber = () => this._web3.eth.blockNumber\n\n  sign = (userAddress, data) =>\n    new Promise((resolve, reject) => {\n      this._web3.eth.sign(userAddress, data, (error, result) => {\n        if (error) reject(error)\n\n        resolve(result)\n      })\n    })\n\n  getBlock = blockNumber =>\n    new Promise((resolve, reject) => {\n      this._web3.eth.getBlock(blockNumber, (error, result) => {\n        if (error) reject(error)\n\n        resolve(result)\n      })\n    })\n\n  doesContractExistAtAddressAsync = async address => {\n    const code = await this._web3.eth.getCode(address)\n    // Regex matches 0x0, 0x00, 0x in order to accommodate poorly implemented clients\n    const codeIsEmpty = /^0x0{0,40}$/i.test(code)\n\n    return !codeIsEmpty\n  }\n\n  _getNetworkIdIfExistsAsync = async () => {\n    if (!_.isUndefined(this.networkIdIfExists)) {\n      return this.networkIdIfExists\n    }\n\n    try {\n      const networkId = await this._getNetworkAsync()\n\n      this.networkIdIfExists = Number(networkId)\n      return this.networkIdIfExists\n    } catch (err) {\n      console.log(err)\n      return undefined\n    }\n  }\n\n  _getNetworkAsync = async () => {\n    const networkId = await this._web3.version.network\n\n    return networkId\n  }\n\n  getBalanceInWeiAsync = owner => {\n    if (_.isUndefined(owner)) {\n      owner = this._web3.eth.accounts[0]\n    }\n\n    let balanceInWei = this._web3.eth.getBalance(owner)\n\n    return balanceInWei.toString()\n  }\n}\n\nexport default Web3Wrapper\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/Web3Wrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 276,
    "kind": "class",
    "name": "Web3Wrapper",
    "memberof": "src/utils/Web3Wrapper.js",
    "static": true,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/Web3Wrapper.js",
    "importStyle": "Web3Wrapper",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 277,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#constructor",
    "access": "public",
    "description": "Constructor Web3 wrapper.",
    "lineNumber": 9,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "The web3 instance."
      }
    ]
  },
  {
    "__docId__": 278,
    "kind": "member",
    "name": "_web3",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#_web3",
    "access": "private",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "member",
    "name": "isAddress",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#isAddress",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "member",
    "name": "getAccount",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getAccount",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "member",
    "name": "getProvider",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getProvider",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "member",
    "name": "getCoinbase",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getCoinbase",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "member",
    "name": "toWei",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#toWei",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "member",
    "name": "fromWei",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#fromWei",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "member",
    "name": "toBigNumber",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#toBigNumber",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "member",
    "name": "blockNumber",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#blockNumber",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "member",
    "name": "sign",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#sign",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "member",
    "name": "getBlock",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getBlock",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "member",
    "name": "doesContractExistAtAddressAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#doesContractExistAtAddressAsync",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "member",
    "name": "_getNetworkIdIfExistsAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#_getNetworkIdIfExistsAsync",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "member",
    "name": "networkIdIfExists",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#networkIdIfExists",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "member",
    "name": "_getNetworkAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#_getNetworkAsync",
    "access": "private",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "member",
    "name": "getBalanceInWeiAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getBalanceInWeiAsync",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "file",
    "name": "src/utils/delegateCalls.js",
    "content": "import _ from 'lodash'\n\n/**\n * delegate calls from a baseClass to a providerClass if the call does not exist in base class\n * @param {object} baseClass - The base object that has first priority to make calls\n * @param {object} providerClass - The class whose methods will be called by baseClass\n * @param {function} middlewareCall - <optional> Middleware function that can act as\n * intermediary between base and provider. Should take a two params which is the provider\n * classes method call and the params passed\n */\nconst delegateCalls = (baseClass, providerClass, middlewareCall) => {\n  // we don't want to delegate any calls that are part of the base class\n  const existingMethods = Object.getOwnPropertyNames(baseClass).concat(\n    Object.getPrototypeOf(baseClass)\n  )\n  // methods of provider\n  const providerMethods = Object.getOwnPropertyNames(providerClass)\n  // calls we will delegate\n  const delegatableMethods = providerMethods.filter(method => {\n    if (\n      !providerClass.hasOwnProperty(method) ||\n      typeof providerClass[method] !== 'function'\n    ) {\n      return false\n    }\n\n    return !_.includes(existingMethods, method)\n  })\n\n  // delegate calls in baseClass\n  delegatableMethods.forEach(methodName => {\n    let curriedCall\n    if (middlewareCall)\n      curriedCall = (...args) =>\n        middlewareCall(providerClass[methodName], ...args)\n    else curriedCall = (...args) => providerClass[methodName](...args)\n    // set method in baseClass\n    baseClass[methodName] = curriedCall\n  })\n}\n\n/**\n{ constant: true,\n  inputs: [],\n  name: 'lastPeriodChange',\n  outputs: [ [Object] ],\n  payable: false,\n  stateMutability: 'view',\n  type: 'function' },\n*/\n\nexport default delegateCalls\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/delegateCalls.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 295,
    "kind": "function",
    "name": "delegateCalls",
    "memberof": "src/utils/delegateCalls.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/delegateCalls.js~delegateCalls",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/delegateCalls.js",
    "importStyle": "delegateCalls",
    "description": "{ constant: true,\ninputs: [],\nname: 'lastPeriodChange',\noutputs: [ [Object] ],\npayable: false,\nstateMutability: 'view',\ntype: 'function' },",
    "lineNumber": 11,
    "params": [
      {
        "name": "baseClass",
        "types": [
          "*"
        ]
      },
      {
        "name": "providerClass",
        "types": [
          "*"
        ]
      },
      {
        "name": "middlewareCall",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 296,
    "kind": "file",
    "name": "src/utils/deployContractAsync.js",
    "content": "import contract from 'truffle-contract'\n\nimport * as ethConstants from '../constants/eth'\nimport { UNABLE_TO_DEPLOY_CONTRACT } from '../constants/error'\n\nimport isRequired from './isRequired'\n\n/**\n * Deploy a contract on the Ethereum network using the contract artifact.\n * @param {string} account - The account to deploy it under.\n * @param {number} value - The value to send.\n * @param {object} artifact - JSON artifact of the contract.\n * @param {object} web3Provider - Web3 Provider object (NOTE NOT Kleros Web3Wrapper)\n * @param {...any} args - Extra arguments.\n * @returns {object} - truffle-contract Object | err The contract object or an error\n */\nconst deployContractAsync = async (\n  account = isRequired('account'),\n  value = isRequired('value'),\n  artifact = isRequired('artifact'),\n  web3Provider = isRequired('web3Provider'),\n  ...args\n) => {\n  try {\n    const MyContract = contract({\n      abi: artifact.abi,\n      unlinked_binary: artifact.bytecode\n        ? artifact.bytecode\n        : artifact.unlinked_binary\n    })\n    MyContract.setProvider(web3Provider)\n\n    return MyContract.new(...args, {\n      from: account,\n      value: value,\n      gas: ethConstants.TRANSACTION.GAS\n    })\n  } catch (err) {\n    console.error(err)\n    throw new Error(UNABLE_TO_DEPLOY_CONTRACT)\n  }\n}\n\nexport default deployContractAsync\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/deployContractAsync.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 297,
    "kind": "function",
    "name": "deployContractAsync",
    "memberof": "src/utils/deployContractAsync.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/utils/deployContractAsync.js~deployContractAsync",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/deployContractAsync.js",
    "importStyle": "deployContractAsync",
    "description": "Deploy a contract on the Ethereum network using the contract artifact.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - truffle-contract Object | err The contract object or an error"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account to deploy it under."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value to send."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "artifact",
        "description": "JSON artifact of the contract."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "Web3 Provider object (NOTE NOT Kleros Web3Wrapper)"
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Extra arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The contract object or an error"
    }
  },
  {
    "__docId__": 298,
    "kind": "file",
    "name": "src/utils/isRequired.js",
    "content": "import { MISSING_PARAMETERS } from '../constants/error'\n\n/**\n * Used as the default parameter for an arguemnt that is considered required. It will\n * throw an error if the argument is not supplied by the user.\n * @param {string} name - The name of the missing argument.\n */\nconst isRequired = name => {\n  throw new Error(MISSING_PARAMETERS(name))\n}\n\nexport default isRequired\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/isRequired.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 299,
    "kind": "function",
    "name": "isRequired",
    "memberof": "src/utils/isRequired.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/isRequired.js~isRequired",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/isRequired.js",
    "importStyle": "isRequired",
    "description": "Used as the default parameter for an arguemnt that is considered required. It will\nthrow an error if the argument is not supplied by the user.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the missing argument."
      }
    ],
    "return": null
  },
  {
    "kind": "index",
    "content": "# Kleros API\n\n<p align=\"center\">\n  <a href=\"https://badge.fury.io/js/kleros-api\"><img src=\"https://badge.fury.io/js/kleros-api.svg\" alt=\"NPM Version\"></a>\n  <a href=\"https://travis-ci.org/kleros/kleros-api\"><img src=\"https://travis-ci.org/kleros/kleros-api.svg?branch=master\" alt=\"Build Status\"></a>\n  <a href=\"https://coveralls.io/github/kleros/kleros-api?branch=master\"><img src=\"https://coveralls.io/repos/github/kleros/kleros-api/badge.svg?branch=master\" alt=\"Coverage Status\"></a>\n  <a href=\"https://david-dm.org/kleros/kleros-api\"><img src=\"https://david-dm.org/kleros/kleros-api.svg\" alt=\"Dependencies\"></a>\n  <a href=\"https://david-dm.org/kleros/kleros-api?type=dev\"><img src=\"https://david-dm.org/kleros/kleros-api/dev-status.svg\" alt=\"Dev Dependencies\"></a>\n  <a href=\"https://github.com/facebook/jest\"><img src=\"https://img.shields.io/badge/tested_with-jest-99424f.svg\" alt=\"Tested with Jest\"></a>\n  <a href=\"https://standardjs.com\"><img src=\"https://img.shields.io/badge/code_style-standard-brightgreen.svg\" alt=\"JavaScript Style Guide\"></a>\n  <a href=\"https://github.com/prettier/prettier\"><img src=\"https://img.shields.io/badge/styled_with-prettier-ff69b4.svg\" alt=\"Styled with Prettier\"></a>\n  <a href=\"https://conventionalcommits.org\"><img src=\"https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg\" alt=\"Conventional Commits\"></a>\n  <a href=\"http://commitizen.github.io/cz-cli/\"><img src=\"https://img.shields.io/badge/commitizen-friendly-brightgreen.svg\" alt=\"Commitizen Friendly\"></a>\n</p>\n\n> This repository contains a Javascript library that provides methods to interact with Kleros arbitrator\n> and Arbitrable contracts. It can be used to develop Relayers or DApps that use Kleros smart contracts.\n\n## Installation\n\n```\nyarn add kleros-api\n```\n\n## Basic Usage\n\nSee the full API docs [here](https://kleros.io/kleros-api/).\n\nThe base Kleros object initializes all of the different kleros api's with the contract\naddresses you pass. This object is useful if your application interacts with both arbitrators,\narbitrable contracts and uses an off chain store to provide metadata on the different disputes\nfor the UI.\n\n```\n// pay arbitration fee.\nimport Kleros from 'kleros-api'\n\nconst KlerosInstance = new Kleros(\n  ETH_PROVIDER, // ethereum provider object\n  KLEROS_STORE_URI, // uri of off chain storage e.g. https://kleros.in\n  ARITRATOR_CONTRACT_ADDRESS, // address of a deployed Kleros arbitrator contract\n  ARBITRABLE_CONTRACT_ADDRESS // address of a deployed arbitrable transaction contract\n)\n\nKlerosInstance.arbitrable.payArbitrationFeeByPartyA() // pay arbitration fee for an arbitrable contract\n```\n\nYou can also use the specific api that best suits your needs.\n\n```\n// deploy a new contract and pay the arbitration fee.\nimport ArbitrableTransaction from 'kleros-api/contracts/implementations/arbitrable/ArbitrableTransaction'\n\n// deploy methods are static\nconst contractInstance = ArbitrableTransaction.deploy(\n    \"0x67a3f2BB8B4B2060875Bd6543156401B817bEd22\", // users address\n    0.15, // amount of ETH to escrow\n    \"0x0\", // hash of the off chain contract\n    \"0x3af76ef44932695a33ba2af52018cd24a74c904f\", // arbitrator address\n    3600, // number of seconds until there is a timeout\n    \"0x0474b723bd4986808366E0DcC2E301515Aa742B4\", // the other party in the contract\n    \"0x0\", // extra data in bytes. This can be used to interact with the arbitrator contract\n    ETH_PROVIDER, // provider object to be used to interact with the network\n  )\n\nconst address = contractInstance.address // get the address of your newly created contract\n\nconst ArbitrableTransactionInstance = new ArbitrableTransaction(address) // instantiate instance of the api\n\nArbitrableTransactionInstance.payArbitrationFeeByPartyA() // pay arbitration fee\n```\n\n## Development\n\nIf you want to contribute to our api or modify it for your usage\n\n## Setup\n\nWe assume that you have node and yarn installed.\n\n```sh\nyarn install\n```\n\n## Test\n\n```sh\nyarn ganache\nyarn test\n```\n\n## Build\n\n```sh\nyarn run build\n```\n",
    "longname": "/Users/samvitello/kleros/kleros-api/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"kleros-api\",\n  \"version\": \"0.5.0\",\n  \"description\":\n    \"A Javascript library that makes it easy to build relayers and other DApps that use the Kleros protocol.\",\n  \"keywords\": [\"Blockchain\", \"Ethereum\", \"Kleros\"],\n  \"main\": \"lib/index.js\",\n  \"module\": \"es/index.js\",\n  \"files\": [\"es\", \"lib\", \"umd\"],\n  \"homepage\": \"https://kleros.io\",\n  \"repository\": \"github:kleros/kleros-api\",\n  \"bugs\": \"https://github.com/kleros/kleros-api/issues\",\n  \"author\": \"Kleros Team <contact@kleros.io> (https://github.com/kleros)\",\n  \"contributors\": [\n    \"Wagner Nicolas <nicolas@kleros.io> (https://github.com/n1c01a5)\",\n    \"Sam Vitello (https://github.com/satello)\",\n    \"Enrique Piqueras <enrique@kleros.io> (https://github.com/epiqueras)\"\n  ],\n  \"license\": \"MIT\",\n  \"private\": false,\n  \"scripts\": {\n    \"docs\": \"esdoc\",\n    \"prettify\": \"kleros-scripts prettify\",\n    \"lint\": \"kleros-scripts lint:js --config ./.eslintrc.js\",\n    \"ganache\": \"ganache-cli -a 15\",\n    \"test\": \"jest --config ./jest.config.js\",\n    \"test:coveralls\": \"coveralls < ./coverage/lcov.info\",\n    \"precommit\": \"kleros-scripts precommit\",\n    \"commitmsg\": \"kleros-scripts commitmsg\",\n    \"cz\": \"kleros-scripts cz\",\n    \"start\": \"babel src --out-dir ./es --watch --source-maps\",\n    \"build\":\n      \"rimraf ./umd ./es ./lib && webpack --env.NODE_ENV=production -p && babel src --out-dir ./es --source-maps && cross-env BABEL_ENV=commonjs babel src --out-dir ./lib --source-maps\"\n  },\n  \"commitlint\": {\n    \"extends\": [\"@commitlint/config-conventional\"]\n  },\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-core\": \"^6.26.0\",\n    \"babel-jest\": \"^22.4.1\",\n    \"babel-loader\": \"^7.1.3\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"babel-preset-stage-2\": \"^6.24.1\",\n    \"coveralls\": \"^3.0.0\",\n    \"cross-env\": \"^5.1.4\",\n    \"esdoc\": \"^1.0.4\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"ganache-cli\": \"^6.1.0\",\n    \"husky\": \"^0.14.3\",\n    \"jest\": \"^22.4.2\",\n    \"kleros-scripts\": \"^0.4.0\",\n    \"rimraf\": \"^2.6.2\",\n    \"standard-version\": \"^4.3.0\",\n    \"webpack\": \"^4.0.1\",\n    \"webpack-cli\": \"^2.0.9\"\n  },\n  \"dependencies\": {\n    \"babel-runtime\": \"^6.26.0\",\n    \"eth-sig-util\": \"^1.4.2\",\n    \"kleros\": \"^0.0.5\",\n    \"kleros-interaction\": \"^0.0.8\",\n    \"lodash\": \"^4.17.4\",\n    \"truffle-contract\": \"^2.0.5\",\n    \"web3\": \"^0.20.1\",\n    \"web3-eth-personal\": \"^1.0.0-beta.34\"\n  }\n}\n",
    "longname": "/Users/samvitello/kleros/kleros-api/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]